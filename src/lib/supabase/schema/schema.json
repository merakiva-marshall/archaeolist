{
  "enums": [],
  "tables": [
    {
      "columns": [
        {
          "name": "id",
          "type": "uuid",
          "description": null,
          "is_identity": false,
          "is_nullable": false,
          "is_updatable": true,
          "default_value": "gen_random_uuid()"
        },
        {
          "name": "page_ref",
          "type": "text",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "reference_name",
          "type": "text",
          "description": null,
          "is_identity": false,
          "is_nullable": false,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "site_id",
          "type": "uuid",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "url",
          "type": "text",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": null
        }
      ],
      "policies": [
        {
          "name": "Public read access for references",
          "command": "r",
          "role_name": null,
          "definition": "true",
          "permissive": true
        },
        {
          "name": "Enable insert for authenticated users only",
          "command": "a",
          "role_name": "authenticated",
          "definition": null,
          "permissive": true
        },
        {
          "name": "Enable update for authenticated users only",
          "command": "w",
          "role_name": "authenticated",
          "definition": "true",
          "permissive": true
        }
      ],
      "table_name": "references",
      "table_type": "BASE TABLE",
      "description": null,
      "table_schema": "public"
    },
    {
      "columns": [
        {
          "name": "address",
          "type": "text",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": false,
          "default_value": null
        },
        {
          "name": "country",
          "type": "text",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": false,
          "default_value": null
        },
        {
          "name": "created_at",
          "type": "timestamp with time zone",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": false,
          "default_value": null
        },
        {
          "name": "description",
          "type": "text",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": false,
          "default_value": null
        },
        {
          "name": "features",
          "type": "text[]",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": false,
          "default_value": null
        },
        {
          "name": "id",
          "type": "uuid",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": false,
          "default_value": null
        },
        {
          "name": "images",
          "type": "jsonb",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": false,
          "default_value": null
        },
        {
          "name": "location",
          "type": "PostGIS geometry",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": false,
          "default_value": null
        },
        {
          "name": "metadata",
          "type": "jsonb",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": false,
          "default_value": null
        },
        {
          "name": "name",
          "type": "text",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": false,
          "default_value": null
        },
        {
          "name": "period",
          "type": "text[]",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": false,
          "default_value": null
        },
        {
          "name": "reference_count",
          "type": "bigint",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": false,
          "default_value": null
        },
        {
          "name": "slug",
          "type": "text",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": false,
          "default_value": null
        },
        {
          "name": "updated_at",
          "type": "timestamp with time zone",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": false,
          "default_value": null
        },
        {
          "name": "wikipedia_url",
          "type": "text",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": false,
          "default_value": null
        }
      ],
      "policies": [],
      "table_name": "sites_with_ref_count",
      "table_type": "VIEW",
      "description": null,
      "table_schema": "public"
    },
    {
      "columns": [
        {
          "name": "area",
          "type": "text",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "buffer_zone",
          "type": "text",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "coordinates",
          "type": "text",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "criteria",
          "type": "text",
          "description": "Criteria under which the site was inscribed'",
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "endangered",
          "type": "text",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "id",
          "type": "uuid",
          "description": null,
          "is_identity": false,
          "is_nullable": false,
          "is_updatable": true,
          "default_value": "gen_random_uuid()"
        },
        {
          "name": "inscription",
          "type": "text",
          "description": "Year the site was inscribed on the World Heritage List",
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "location",
          "type": "text",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "reference",
          "type": "text",
          "description": "Unique identifier assigned by UNESCO",
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "site_id",
          "type": "uuid",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "type",
          "type": "text",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "unesco_data",
          "type": "jsonb",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": null
        }
      ],
      "policies": [
        {
          "name": "Public read access for unesco_sites",
          "command": "r",
          "role_name": null,
          "definition": "true",
          "permissive": true
        },
        {
          "name": "Enable insert for authenticated users only",
          "command": "a",
          "role_name": "authenticated",
          "definition": null,
          "permissive": true
        },
        {
          "name": "Enable update for authenticated users only",
          "command": "w",
          "role_name": "authenticated",
          "definition": "true",
          "permissive": true
        }
      ],
      "table_name": "unesco_sites",
      "table_type": "BASE TABLE",
      "description": null,
      "table_schema": "public"
    },
    {
      "columns": [
        {
          "name": "address",
          "type": "text",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "archaeological_site_yn",
          "type": "boolean",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": "true"
        },
        {
          "name": "country",
          "type": "text",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "country_slug",
          "type": "text",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "created_at",
          "type": "timestamp with time zone",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": "now()"
        },
        {
          "name": "description",
          "type": "text",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "features",
          "type": "text[]",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "id",
          "type": "uuid",
          "description": null,
          "is_identity": false,
          "is_nullable": false,
          "is_updatable": true,
          "default_value": "gen_random_uuid()"
        },
        {
          "name": "images",
          "type": "jsonb",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": "'[]'::jsonb"
        },
        {
          "name": "is_unesco",
          "type": "boolean",
          "description": "for \"true\" links to \"unesco_sites\" table",
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": "false"
        },
        {
          "name": "last_processed_at",
          "type": "timestamp with time zone",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "location",
          "type": "PostGIS geometry",
          "description": "PostGIS type",
          "is_identity": false,
          "is_nullable": false,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "metadata",
          "type": "jsonb",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": "'{}'::jsonb"
        },
        {
          "name": "name",
          "type": "text",
          "description": null,
          "is_identity": false,
          "is_nullable": false,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "period",
          "type": "text[]",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "processed_features",
          "type": "jsonb",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "processed_periods",
          "type": "jsonb",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "short_description",
          "type": "text",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "slug",
          "type": "text",
          "description": "main key",
          "is_identity": false,
          "is_nullable": false,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "timeline",
          "type": "jsonb",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": null
        },
        {
          "name": "updated_at",
          "type": "timestamp with time zone",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": "now()"
        },
        {
          "name": "wikipedia_url",
          "type": "text",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": true,
          "default_value": null
        }
      ],
      "policies": [
        {
          "name": "Public read access for sites",
          "command": "r",
          "role_name": null,
          "definition": "true",
          "permissive": true
        },
        {
          "name": "Enable insert for authenticated users only",
          "command": "a",
          "role_name": "authenticated",
          "definition": null,
          "permissive": true
        },
        {
          "name": "Enable update for authenticated users only",
          "command": "w",
          "role_name": "authenticated",
          "definition": "true",
          "permissive": true
        }
      ],
      "table_name": "sites",
      "table_type": "BASE TABLE",
      "description": null,
      "table_schema": "public"
    },
    {
      "columns": [
        {
          "name": "calls",
          "type": "bigint",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": false,
          "default_value": null
        },
        {
          "name": "mean_exec_time",
          "type": "double precision",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": false,
          "default_value": null
        },
        {
          "name": "query",
          "type": "text",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": false,
          "default_value": null
        },
        {
          "name": "rows",
          "type": "bigint",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": false,
          "default_value": null
        },
        {
          "name": "total_exec_seconds",
          "type": "double precision",
          "description": null,
          "is_identity": false,
          "is_nullable": true,
          "is_updatable": false,
          "default_value": null
        }
      ],
      "policies": [],
      "table_name": "query_stats",
      "table_type": "VIEW",
      "description": null,
      "table_schema": "public"
    }
  ],
  "indexes": [
    {
      "definition": "CREATE UNIQUE INDEX references_pkey ON public.\"references\" USING btree (id)",
      "index_name": "references_pkey",
      "table_name": "references"
    },
    {
      "definition": "CREATE INDEX references_site_id_idx ON public.\"references\" USING btree (site_id)",
      "index_name": "references_site_id_idx",
      "table_name": "references"
    },
    {
      "definition": "CREATE UNIQUE INDEX unesco_sites_pkey ON public.unesco_sites USING btree (id)",
      "index_name": "unesco_sites_pkey",
      "table_name": "unesco_sites"
    },
    {
      "definition": "CREATE UNIQUE INDEX unesco_sites_site_id_key ON public.unesco_sites USING btree (site_id)",
      "index_name": "unesco_sites_site_id_key",
      "table_name": "unesco_sites"
    },
    {
      "definition": "CREATE INDEX unesco_sites_site_id_idx ON public.unesco_sites USING btree (site_id)",
      "index_name": "unesco_sites_site_id_idx",
      "table_name": "unesco_sites"
    },
    {
      "definition": "CREATE UNIQUE INDEX sites_pkey ON public.sites USING btree (id)",
      "index_name": "sites_pkey",
      "table_name": "sites"
    },
    {
      "definition": "CREATE UNIQUE INDEX sites_slug_key ON public.sites USING btree (slug)",
      "index_name": "sites_slug_key",
      "table_name": "sites"
    },
    {
      "definition": "CREATE INDEX sites_location_idx ON public.sites USING gist (location)",
      "index_name": "sites_location_idx",
      "table_name": "sites"
    },
    {
      "definition": "CREATE INDEX idx_sites_last_processed_at ON public.sites USING btree (last_processed_at)",
      "index_name": "idx_sites_last_processed_at",
      "table_name": "sites"
    },
    {
      "definition": "CREATE INDEX map_clusters_z5_site_count_idx ON public.map_clusters_z5 USING btree (site_count)",
      "index_name": "map_clusters_z5_site_count_idx",
      "table_name": "map_clusters_z5"
    },
    {
      "definition": "CREATE INDEX map_clusters_z5_location_idx ON public.map_clusters_z5 USING gist (location) WITH (fillfactor='90')",
      "index_name": "map_clusters_z5_location_idx",
      "table_name": "map_clusters_z5"
    },
    {
      "definition": "CREATE INDEX map_clusters_z5_location_partial_idx ON public.map_clusters_z5 USING gist (location) WHERE (location IS NOT NULL)",
      "index_name": "map_clusters_z5_location_partial_idx",
      "table_name": "map_clusters_z5"
    }
  ],
  "triggers": [
    {
      "name": "sites_updated_at",
      "table": "public.sites",
      "events": [
        "INSERT",
        "DELETE"
      ],
      "function": "update_updated_at",
      "description": null
    },
    {
      "name": "refresh_clusters_trigger",
      "table": "public.sites",
      "events": [
        "UPDATE",
        "TRUNCATE"
      ],
      "function": "refresh_map_clusters",
      "description": null
    }
  ],
  "functions": [
    {
      "name": "get_table_schema",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.get_table_schema(p_table_name text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  result jsonb;\nBEGIN\n  RAISE NOTICE 'Fetching schema for table: %', p_table_name;\n\n  SELECT jsonb_object_agg(columns.column_name, jsonb_build_object(\n    'data_type', columns.data_type,\n    'is_nullable', columns.is_nullable,\n    'column_default', columns.column_default\n  ))\n  INTO result\n  FROM information_schema.columns\n  WHERE columns.table_schema = 'public' AND columns.table_name = p_table_name;\n\n  IF result IS NULL THEN\n    RAISE EXCEPTION 'No columns found for table: %', p_table_name;\n  END IF;\n\n  RAISE NOTICE 'Schema fetched successfully: %', result;\n  RETURN result;\nEXCEPTION\n  WHEN OTHERS THEN\n    RAISE NOTICE 'Error in get_table_schema: %', SQLERRM;\n    RAISE;\nEND;\n$function$\n",
      "language": "plpgsql",
      "arguments": "p_table_name text",
      "volatility": "volatile",
      "description": null,
      "result_type": "jsonb",
      "security_definer": true
    },
    {
      "name": "refresh_map_clusters",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.refresh_map_clusters()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  REFRESH MATERIALIZED VIEW CONCURRENTLY map_clusters_z5;\n  RETURN NULL;\nEND;\n$function$\n",
      "language": "plpgsql",
      "arguments": "",
      "volatility": "volatile",
      "description": null,
      "result_type": "trigger",
      "security_definer": false
    },
    {
      "name": "get_clustered_sites",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.get_clustered_sites(zoom_level integer, bounds geometry)\n RETURNS TABLE(id uuid, location geometry, site_count integer, unesco_count integer, site_names text[], periods text[])\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    c.id,\n    c.location,\n    c.site_count,\n    c.unesco_count,\n    c.site_names,\n    c.periods\n  FROM map_clusters_z5 c\n  WHERE ST_Intersects(c.location, bounds);\nEND;\n$function$\n",
      "language": "plpgsql",
      "arguments": "zoom_level integer, bounds geometry",
      "volatility": "stable",
      "description": null,
      "result_type": "TABLE(id uuid, location geometry, site_count integer, unesco_count integer, site_names text[], periods text[])",
      "security_definer": true
    },
    {
      "name": "search_sites",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.search_sites(search_term text)\n RETURNS TABLE(id uuid, name text, slug text, description text, country text, reference_count bigint)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        s.id,\n        s.name,\n        s.slug,\n        s.description,\n        s.country,\n        COUNT(r.id) AS reference_count\n    FROM \n        public.sites s\n    LEFT JOIN \n        public.references r ON s.id = r.site_id\n    WHERE \n        s.name ILIKE '%' || search_term || '%'\n        OR s.description ILIKE '%' || search_term || '%'\n        OR s.country ILIKE '%' || search_term || '%'\n    GROUP BY \n        s.id\n    ORDER BY \n        s.name;\nEND;\n$function$\n",
      "language": "plpgsql",
      "arguments": "search_term text",
      "volatility": "volatile",
      "description": null,
      "result_type": "TABLE(id uuid, name text, slug text, description text, country text, reference_count bigint)",
      "security_definer": false
    },
    {
      "name": "get_sites_in_viewport",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.get_sites_in_viewport(viewport_west double precision, viewport_south double precision, viewport_east double precision, viewport_north double precision)\n RETURNS TABLE(id uuid, name text, description text, location jsonb, address text, period text[], features text[], country text, country_slug text, slug text)\n LANGUAGE sql\nAS $function$\n  SELECT \n    id, \n    name,\n    description,\n    jsonb_build_object(\n      'coordinates',\n      jsonb_build_array(\n        ST_X(location::geometry),\n        ST_Y(location::geometry)\n      )\n    ) as location,\n    address,\n    period,\n    features,\n    country,\n    country_slug,\n    slug\n  FROM sites\n  WHERE location && \n    ST_MakeEnvelope(\n      viewport_west, \n      viewport_south, \n      viewport_east, \n      viewport_north, \n      4326\n    );\n$function$\n",
      "language": "sql",
      "arguments": "viewport_west double precision, viewport_south double precision, viewport_east double precision, viewport_north double precision",
      "volatility": "volatile",
      "description": null,
      "result_type": "TABLE(id uuid, name text, description text, location jsonb, address text, period text[], features text[], country text, country_slug text, slug text)",
      "security_definer": false
    },
    {
      "name": "check_query_performance",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.check_query_performance()\n RETURNS TABLE(view_name text, last_analyze timestamp without time zone, estimated_rows bigint, live_rows bigint, last_vacuum timestamp without time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        schemaname || '.' || relname as view_name,\n        last_analyze,\n        n_live_tup as estimated_rows,\n        n_live_tup as live_rows,\n        last_vacuum\n    FROM pg_stat_user_tables\n    WHERE relname LIKE 'map_clusters%'\n    ORDER BY last_analyze DESC;\nEND;\n$function$\n",
      "language": "plpgsql",
      "arguments": "",
      "volatility": "volatile",
      "description": null,
      "result_type": "TABLE(view_name text, last_analyze timestamp without time zone, estimated_rows bigint, live_rows bigint, last_vacuum timestamp without time zone)",
      "security_definer": false
    },
    {
      "name": "point",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.point(geometry)\n RETURNS point\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$geometry_to_point$function$\n",
      "language": "c",
      "arguments": "geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "point",
      "security_definer": false
    },
    {
      "name": "geometry",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.geometry(path)\n RETURNS geometry\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$path_to_geometry$function$\n",
      "language": "c",
      "arguments": "path",
      "volatility": "immutable",
      "description": null,
      "result_type": "geometry",
      "security_definer": false
    },
    {
      "name": "path",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.path(geometry)\n RETURNS path\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$geometry_to_path$function$\n",
      "language": "c",
      "arguments": "geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "path",
      "security_definer": false
    },
    {
      "name": "geometry",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.geometry(polygon)\n RETURNS geometry\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$polygon_to_geometry$function$\n",
      "language": "c",
      "arguments": "polygon",
      "volatility": "immutable",
      "description": null,
      "result_type": "geometry",
      "security_definer": false
    },
    {
      "name": "polygon",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.polygon(geometry)\n RETURNS polygon\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$geometry_to_polygon$function$\n",
      "language": "c",
      "arguments": "geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "polygon",
      "security_definer": false
    },
    {
      "name": "box3d_in",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.box3d_in(cstring)\n RETURNS box3d\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$BOX3D_in$function$\n",
      "language": "c",
      "arguments": "cstring",
      "volatility": "immutable",
      "description": null,
      "result_type": "box3d",
      "security_definer": false
    },
    {
      "name": "box3d_out",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.box3d_out(box3d)\n RETURNS cstring\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$BOX3D_out$function$\n",
      "language": "c",
      "arguments": "box3d",
      "volatility": "immutable",
      "description": null,
      "result_type": "cstring",
      "security_definer": false
    },
    {
      "name": "box2d_in",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.box2d_in(cstring)\n RETURNS box2d\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$BOX2D_in$function$\n",
      "language": "c",
      "arguments": "cstring",
      "volatility": "immutable",
      "description": null,
      "result_type": "box2d",
      "security_definer": false
    },
    {
      "name": "box2d_out",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.box2d_out(box2d)\n RETURNS cstring\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$BOX2D_out$function$\n",
      "language": "c",
      "arguments": "box2d",
      "volatility": "immutable",
      "description": null,
      "result_type": "cstring",
      "security_definer": false
    },
    {
      "name": "box2df_in",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.box2df_in(cstring)\n RETURNS box2df\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$box2df_in$function$\n",
      "language": "c",
      "arguments": "cstring",
      "volatility": "immutable",
      "description": null,
      "result_type": "box2df",
      "security_definer": false
    },
    {
      "name": "box2df_out",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.box2df_out(box2df)\n RETURNS cstring\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$box2df_out$function$\n",
      "language": "c",
      "arguments": "box2df",
      "volatility": "immutable",
      "description": null,
      "result_type": "cstring",
      "security_definer": false
    },
    {
      "name": "gidx_in",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.gidx_in(cstring)\n RETURNS gidx\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$gidx_in$function$\n",
      "language": "c",
      "arguments": "cstring",
      "volatility": "immutable",
      "description": null,
      "result_type": "gidx",
      "security_definer": false
    },
    {
      "name": "gidx_out",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.gidx_out(gidx)\n RETURNS cstring\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$gidx_out$function$\n",
      "language": "c",
      "arguments": "gidx",
      "volatility": "immutable",
      "description": null,
      "result_type": "cstring",
      "security_definer": false
    },
    {
      "name": "_postgis_selectivity",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._postgis_selectivity(tbl regclass, att_name text, geom geometry, mode text DEFAULT '2'::text)\n RETURNS double precision\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$_postgis_gserialized_sel$function$\n",
      "language": "c",
      "arguments": "tbl regclass, att_name text, geom geometry, mode text DEFAULT '2'::text",
      "volatility": "volatile",
      "description": null,
      "result_type": "double precision",
      "security_definer": false
    },
    {
      "name": "_postgis_join_selectivity",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._postgis_join_selectivity(regclass, text, regclass, text, text DEFAULT '2'::text)\n RETURNS double precision\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$_postgis_gserialized_joinsel$function$\n",
      "language": "c",
      "arguments": "regclass, text, regclass, text, text DEFAULT '2'::text",
      "volatility": "volatile",
      "description": null,
      "result_type": "double precision",
      "security_definer": false
    },
    {
      "name": "_postgis_stats",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._postgis_stats(tbl regclass, att_name text, text DEFAULT '2'::text)\n RETURNS text\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$_postgis_gserialized_stats$function$\n",
      "language": "c",
      "arguments": "tbl regclass, att_name text, text DEFAULT '2'::text",
      "volatility": "volatile",
      "description": null,
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "_postgis_index_extent",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._postgis_index_extent(tbl regclass, col text)\n RETURNS box2d\n LANGUAGE c\n STABLE STRICT\nAS '$libdir/postgis-3', $function$_postgis_gserialized_index_extent$function$\n",
      "language": "c",
      "arguments": "tbl regclass, col text",
      "volatility": "stable",
      "description": null,
      "result_type": "box2d",
      "security_definer": false
    },
    {
      "name": "gserialized_gist_sel_2d",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.gserialized_gist_sel_2d(internal, oid, internal, integer)\n RETURNS double precision\n LANGUAGE c\n PARALLEL SAFE\nAS '$libdir/postgis-3', $function$gserialized_gist_sel_2d$function$\n",
      "language": "c",
      "arguments": "internal, oid, internal, integer",
      "volatility": "volatile",
      "description": null,
      "result_type": "double precision",
      "security_definer": false
    },
    {
      "name": "gserialized_gist_sel_nd",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.gserialized_gist_sel_nd(internal, oid, internal, integer)\n RETURNS double precision\n LANGUAGE c\n PARALLEL SAFE\nAS '$libdir/postgis-3', $function$gserialized_gist_sel_nd$function$\n",
      "language": "c",
      "arguments": "internal, oid, internal, integer",
      "volatility": "volatile",
      "description": null,
      "result_type": "double precision",
      "security_definer": false
    },
    {
      "name": "gserialized_gist_joinsel_2d",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.gserialized_gist_joinsel_2d(internal, oid, internal, smallint)\n RETURNS double precision\n LANGUAGE c\n PARALLEL SAFE\nAS '$libdir/postgis-3', $function$gserialized_gist_joinsel_2d$function$\n",
      "language": "c",
      "arguments": "internal, oid, internal, smallint",
      "volatility": "volatile",
      "description": null,
      "result_type": "double precision",
      "security_definer": false
    },
    {
      "name": "gserialized_gist_joinsel_nd",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.gserialized_gist_joinsel_nd(internal, oid, internal, smallint)\n RETURNS double precision\n LANGUAGE c\n PARALLEL SAFE\nAS '$libdir/postgis-3', $function$gserialized_gist_joinsel_nd$function$\n",
      "language": "c",
      "arguments": "internal, oid, internal, smallint",
      "volatility": "volatile",
      "description": null,
      "result_type": "double precision",
      "security_definer": false
    },
    {
      "name": "_postgis_deprecate",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._postgis_deprecate(oldname text, newname text, version text)\n RETURNS void\n LANGUAGE plpgsql\n IMMUTABLE STRICT COST 500\nAS $function$\nDECLARE\n  curver_text text;\nBEGIN\n  --\n  -- Raises a NOTICE if it was deprecated in this version,\n  -- a WARNING if in a previous version (only up to minor version checked)\n  --\n\tcurver_text := '3.3.2';\n\tIF pg_catalog.split_part(curver_text,'.',1)::int > pg_catalog.split_part(version,'.',1)::int OR\n\t   ( pg_catalog.split_part(curver_text,'.',1) = pg_catalog.split_part(version,'.',1) AND\n\t\t pg_catalog.split_part(curver_text,'.',2) != split_part(version,'.',2) )\n\tTHEN\n\t  RAISE WARNING '% signature was deprecated in %. Please use %', oldname, version, newname;\n\tELSE\n\t  RAISE DEBUG '% signature was deprecated in %. Please use %', oldname, version, newname;\n\tEND IF;\nEND;\n$function$\n",
      "language": "plpgsql",
      "arguments": "oldname text, newname text, version text",
      "volatility": "immutable",
      "description": null,
      "result_type": "void",
      "security_definer": false
    },
    {
      "name": "spheroid_in",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.spheroid_in(cstring)\n RETURNS spheroid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$ellipsoid_in$function$\n",
      "language": "c",
      "arguments": "cstring",
      "volatility": "immutable",
      "description": null,
      "result_type": "spheroid",
      "security_definer": false
    },
    {
      "name": "spheroid_out",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.spheroid_out(spheroid)\n RETURNS cstring\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$ellipsoid_out$function$\n",
      "language": "c",
      "arguments": "spheroid",
      "volatility": "immutable",
      "description": null,
      "result_type": "cstring",
      "security_definer": false
    },
    {
      "name": "geometry",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.geometry(geometry, integer, boolean)\n RETURNS geometry\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$geometry_enforce_typmod$function$\n",
      "language": "c",
      "arguments": "geometry, integer, boolean",
      "volatility": "immutable",
      "description": null,
      "result_type": "geometry",
      "security_definer": false
    },
    {
      "name": "geometry",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.geometry(point)\n RETURNS geometry\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$point_to_geometry$function$\n",
      "language": "c",
      "arguments": "point",
      "volatility": "immutable",
      "description": null,
      "result_type": "geometry",
      "security_definer": false
    },
    {
      "name": "postgis_getbbox",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_getbbox(geometry)\n RETURNS box2d\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$LWGEOM_to_BOX2DF$function$\n",
      "language": "c",
      "arguments": "geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "box2d",
      "security_definer": false
    },
    {
      "name": "postgis_addbbox",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_addbbox(geometry)\n RETURNS geometry\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 50\nAS '$libdir/postgis-3', $function$LWGEOM_addBBOX$function$\n",
      "language": "c",
      "arguments": "geometry",
      "volatility": "immutable",
      "description": "args: geomA - Add bounding box to the geometry.",
      "result_type": "geometry",
      "security_definer": false
    },
    {
      "name": "postgis_dropbbox",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_dropbbox(geometry)\n RETURNS geometry\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 50\nAS '$libdir/postgis-3', $function$LWGEOM_dropBBOX$function$\n",
      "language": "c",
      "arguments": "geometry",
      "volatility": "immutable",
      "description": "args: geomA - Drop the bounding box cache from the geometry.",
      "result_type": "geometry",
      "security_definer": false
    },
    {
      "name": "postgis_hasbbox",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_hasbbox(geometry)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$LWGEOM_hasBBOX$function$\n",
      "language": "c",
      "arguments": "geometry",
      "volatility": "immutable",
      "description": "args: geomA - Returns TRUE if the bbox of this geometry is cached, FALSE otherwise.",
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "postgis_noop",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_noop(geometry)\n RETURNS geometry\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$LWGEOM_noop$function$\n",
      "language": "c",
      "arguments": "geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "geometry",
      "security_definer": false
    },
    {
      "name": "postgis_geos_noop",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_geos_noop(geometry)\n RETURNS geometry\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$GEOSnoop$function$\n",
      "language": "c",
      "arguments": "geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "geometry",
      "security_definer": false
    },
    {
      "name": "geomfromewkb",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.geomfromewkb(bytea)\n RETURNS geometry\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 50\nAS '$libdir/postgis-3', $function$LWGEOMFromEWKB$function$\n",
      "language": "c",
      "arguments": "bytea",
      "volatility": "immutable",
      "description": null,
      "result_type": "geometry",
      "security_definer": false
    },
    {
      "name": "geomfromewkt",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.geomfromewkt(text)\n RETURNS geometry\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 50\nAS '$libdir/postgis-3', $function$parse_WKT_lwgeom$function$\n",
      "language": "c",
      "arguments": "text",
      "volatility": "immutable",
      "description": null,
      "result_type": "geometry",
      "security_definer": false
    },
    {
      "name": "postgis_cache_bbox",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_cache_bbox()\n RETURNS trigger\n LANGUAGE c\nAS '$libdir/postgis-3', $function$cache_bbox$function$\n",
      "language": "c",
      "arguments": "",
      "volatility": "volatile",
      "description": null,
      "result_type": "trigger",
      "security_definer": false
    },
    {
      "name": "populate_geometry_columns",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.populate_geometry_columns(use_typmod boolean DEFAULT true)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n\tinserted\tinteger;\n\toldcount\tinteger;\n\tprobed\t  integer;\n\tstale\t   integer;\n\tgcs\t\t RECORD;\n\tgc\t\t  RECORD;\n\tgsrid\t   integer;\n\tgndims\t  integer;\n\tgtype\t   text;\n\tquery\t   text;\n\tgc_is_valid boolean;\n\nBEGIN\n\tSELECT count(*) INTO oldcount FROM public.geometry_columns;\n\tinserted := 0;\n\n\t-- Count the number of geometry columns in all tables and views\n\tSELECT count(DISTINCT c.oid) INTO probed\n\tFROM pg_class c,\n\t\t pg_attribute a,\n\t\t pg_type t,\n\t\t pg_namespace n\n\tWHERE c.relkind IN('r','v','f', 'p')\n\t\tAND t.typname = 'geometry'\n\t\tAND a.attisdropped = false\n\t\tAND a.atttypid = t.oid\n\t\tAND a.attrelid = c.oid\n\t\tAND c.relnamespace = n.oid\n\t\tAND n.nspname NOT ILIKE 'pg_temp%' AND c.relname != 'raster_columns' ;\n\n\t-- Iterate through all non-dropped geometry columns\n\tRAISE DEBUG 'Processing Tables.....';\n\n\tFOR gcs IN\n\tSELECT DISTINCT ON (c.oid) c.oid, n.nspname, c.relname\n\t\tFROM pg_class c,\n\t\t\t pg_attribute a,\n\t\t\t pg_type t,\n\t\t\t pg_namespace n\n\t\tWHERE c.relkind IN( 'r', 'f', 'p')\n\t\tAND t.typname = 'geometry'\n\t\tAND a.attisdropped = false\n\t\tAND a.atttypid = t.oid\n\t\tAND a.attrelid = c.oid\n\t\tAND c.relnamespace = n.oid\n\t\tAND n.nspname NOT ILIKE 'pg_temp%' AND c.relname != 'raster_columns'\n\tLOOP\n\n\t\tinserted := inserted + public.populate_geometry_columns(gcs.oid, use_typmod);\n\tEND LOOP;\n\n\tIF oldcount > inserted THEN\n\t\tstale = oldcount-inserted;\n\tELSE\n\t\tstale = 0;\n\tEND IF;\n\n\tRETURN 'probed:' ||probed|| ' inserted:'||inserted;\nEND\n\n$function$\n",
      "language": "plpgsql",
      "arguments": "use_typmod boolean DEFAULT true",
      "volatility": "volatile",
      "description": "args: use_typmod=true - Ensures geometry columns are defined with type modifiers or have appropriate spatial constraints.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "populate_geometry_columns",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.populate_geometry_columns(tbl_oid oid, use_typmod boolean DEFAULT true)\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n\tgcs\t\t RECORD;\n\tgc\t\t  RECORD;\n\tgc_old\t  RECORD;\n\tgsrid\t   integer;\n\tgndims\t  integer;\n\tgtype\t   text;\n\tquery\t   text;\n\tgc_is_valid boolean;\n\tinserted\tinteger;\n\tconstraint_successful boolean := false;\n\nBEGIN\n\tinserted := 0;\n\n\t-- Iterate through all geometry columns in this table\n\tFOR gcs IN\n\tSELECT n.nspname, c.relname, a.attname, c.relkind\n\t\tFROM pg_class c,\n\t\t\t pg_attribute a,\n\t\t\t pg_type t,\n\t\t\t pg_namespace n\n\t\tWHERE c.relkind IN('r', 'f', 'p')\n\t\tAND t.typname = 'geometry'\n\t\tAND a.attisdropped = false\n\t\tAND a.atttypid = t.oid\n\t\tAND a.attrelid = c.oid\n\t\tAND c.relnamespace = n.oid\n\t\tAND n.nspname NOT ILIKE 'pg_temp%'\n\t\tAND c.oid = tbl_oid\n\tLOOP\n\n\t\tRAISE DEBUG 'Processing column %.%.%', gcs.nspname, gcs.relname, gcs.attname;\n\n\t\tgc_is_valid := true;\n\t\t-- Find the srid, coord_dimension, and type of current geometry\n\t\t-- in geometry_columns -- which is now a view\n\n\t\tSELECT type, srid, coord_dimension, gcs.relkind INTO gc_old\n\t\t\tFROM geometry_columns\n\t\t\tWHERE f_table_schema = gcs.nspname AND f_table_name = gcs.relname AND f_geometry_column = gcs.attname;\n\n\t\tIF upper(gc_old.type) = 'GEOMETRY' THEN\n\t\t-- This is an unconstrained geometry we need to do something\n\t\t-- We need to figure out what to set the type by inspecting the data\n\t\t\tEXECUTE 'SELECT public.ST_srid(' || quote_ident(gcs.attname) || ') As srid, public.GeometryType(' || quote_ident(gcs.attname) || ') As type, public.ST_NDims(' || quote_ident(gcs.attname) || ') As dims ' ||\n\t\t\t\t\t ' FROM ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) ||\n\t\t\t\t\t ' WHERE ' || quote_ident(gcs.attname) || ' IS NOT NULL LIMIT 1;'\n\t\t\t\tINTO gc;\n\t\t\tIF gc IS NULL THEN -- there is no data so we can not determine geometry type\n\t\t\t\tRAISE WARNING 'No data in table %.%, so no information to determine geometry type and srid', gcs.nspname, gcs.relname;\n\t\t\t\tRETURN 0;\n\t\t\tEND IF;\n\t\t\tgsrid := gc.srid; gtype := gc.type; gndims := gc.dims;\n\n\t\t\tIF use_typmod THEN\n\t\t\t\tBEGIN\n\t\t\t\t\tEXECUTE 'ALTER TABLE ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || ' ALTER COLUMN ' || quote_ident(gcs.attname) ||\n\t\t\t\t\t\t' TYPE geometry(' || postgis_type_name(gtype, gndims, true) || ', ' || gsrid::text  || ') ';\n\t\t\t\t\tinserted := inserted + 1;\n\t\t\t\tEXCEPTION\n\t\t\t\t\t\tWHEN invalid_parameter_value OR feature_not_supported THEN\n\t\t\t\t\t\tRAISE WARNING 'Could not convert ''%'' in ''%.%'' to use typmod with srid %, type %: %', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname), gsrid, postgis_type_name(gtype, gndims, true), SQLERRM;\n\t\t\t\t\t\t\tgc_is_valid := false;\n\t\t\t\tEND;\n\n\t\t\tELSE\n\t\t\t\t-- Try to apply srid check to column\n\t\t\t\tconstraint_successful = false;\n\t\t\t\tIF (gsrid > 0 AND postgis_constraint_srid(gcs.nspname, gcs.relname,gcs.attname) IS NULL ) THEN\n\t\t\t\t\tBEGIN\n\t\t\t\t\t\tEXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) ||\n\t\t\t\t\t\t\t\t ' ADD CONSTRAINT ' || quote_ident('enforce_srid_' || gcs.attname) ||\n\t\t\t\t\t\t\t\t ' CHECK (ST_srid(' || quote_ident(gcs.attname) || ') = ' || gsrid || ')';\n\t\t\t\t\t\tconstraint_successful := true;\n\t\t\t\t\tEXCEPTION\n\t\t\t\t\t\tWHEN check_violation THEN\n\t\t\t\t\t\t\tRAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not apply constraint CHECK (st_srid(%) = %)', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname), quote_ident(gcs.attname), gsrid;\n\t\t\t\t\t\t\tgc_is_valid := false;\n\t\t\t\t\tEND;\n\t\t\t\tEND IF;\n\n\t\t\t\t-- Try to apply ndims check to column\n\t\t\t\tIF (gndims IS NOT NULL AND postgis_constraint_dims(gcs.nspname, gcs.relname,gcs.attname) IS NULL ) THEN\n\t\t\t\t\tBEGIN\n\t\t\t\t\t\tEXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '\n\t\t\t\t\t\t\t\t ADD CONSTRAINT ' || quote_ident('enforce_dims_' || gcs.attname) || '\n\t\t\t\t\t\t\t\t CHECK (st_ndims(' || quote_ident(gcs.attname) || ') = '||gndims||')';\n\t\t\t\t\t\tconstraint_successful := true;\n\t\t\t\t\tEXCEPTION\n\t\t\t\t\t\tWHEN check_violation THEN\n\t\t\t\t\t\t\tRAISE WARNING 'Not inserting ''%'' in ''%.%'' into geometry_columns: could not apply constraint CHECK (st_ndims(%) = %)', quote_ident(gcs.attname), quote_ident(gcs.nspname), quote_ident(gcs.relname), quote_ident(gcs.attname), gndims;\n\t\t\t\t\t\t\tgc_is_valid := false;\n\t\t\t\t\tEND;\n\t\t\t\tEND IF;\n\n\t\t\t\t-- Try to apply geometrytype check to column\n\t\t\t\tIF (gtype IS NOT NULL AND postgis_constraint_type(gcs.nspname, gcs.relname,gcs.attname) IS NULL ) THEN\n\t\t\t\t\tBEGIN\n\t\t\t\t\t\tEXECUTE 'ALTER TABLE ONLY ' || quote_ident(gcs.nspname) || '.' || quote_ident(gcs.relname) || '\n\t\t\t\t\t\tADD CONSTRAINT ' || quote_ident('enforce_geotype_' || gcs.attname) || '\n\t\t\t\t\t\tCHECK (geometrytype(' || quote_ident(gcs.attname) || ') = ' || quote_literal(gtype) || ')';\n\t\t\t\t\t\tconstraint_successful := true;\n\t\t\t\t\tEXCEPTION\n\t\t\t\t\t\tWHEN check_violation THEN\n\t\t\t\t\t\t\t-- No geometry check can be applied. This column contains a number of geometry types.\n\t\t\t\t\t\t\tRAISE WARNING 'Could not add geometry type check (%) to table column: %.%.%', gtype, quote_ident(gcs.nspname),quote_ident(gcs.relname),quote_ident(gcs.attname);\n\t\t\t\t\tEND;\n\t\t\t\tEND IF;\n\t\t\t\t --only count if we were successful in applying at least one constraint\n\t\t\t\tIF constraint_successful THEN\n\t\t\t\t\tinserted := inserted + 1;\n\t\t\t\tEND IF;\n\t\t\tEND IF;\n\t\tEND IF;\n\n\tEND LOOP;\n\n\tRETURN inserted;\nEND\n\n$function$\n",
      "language": "plpgsql",
      "arguments": "tbl_oid oid, use_typmod boolean DEFAULT true",
      "volatility": "volatile",
      "description": "args: relation_oid, use_typmod=true - Ensures geometry columns are defined with type modifiers or have appropriate spatial constraints.",
      "result_type": "integer",
      "security_definer": false
    },
    {
      "name": "addgeometrycolumn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.addgeometrycolumn(catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true)\n RETURNS text\n LANGUAGE plpgsql\n STRICT\nAS $function$\nDECLARE\n\trec RECORD;\n\tsr varchar;\n\treal_schema name;\n\tsql text;\n\tnew_srid integer;\n\nBEGIN\n\n\t-- Verify geometry type\n\tIF (postgis_type_name(new_type,new_dim) IS NULL )\n\tTHEN\n\t\tRAISE EXCEPTION 'Invalid type name \"%(%)\" - valid ones are:\n\tPOINT, MULTIPOINT,\n\tLINESTRING, MULTILINESTRING,\n\tPOLYGON, MULTIPOLYGON,\n\tCIRCULARSTRING, COMPOUNDCURVE, MULTICURVE,\n\tCURVEPOLYGON, MULTISURFACE,\n\tGEOMETRY, GEOMETRYCOLLECTION,\n\tPOINTM, MULTIPOINTM,\n\tLINESTRINGM, MULTILINESTRINGM,\n\tPOLYGONM, MULTIPOLYGONM,\n\tCIRCULARSTRINGM, COMPOUNDCURVEM, MULTICURVEM\n\tCURVEPOLYGONM, MULTISURFACEM, TRIANGLE, TRIANGLEM,\n\tPOLYHEDRALSURFACE, POLYHEDRALSURFACEM, TIN, TINM\n\tor GEOMETRYCOLLECTIONM', new_type, new_dim;\n\t\tRETURN 'fail';\n\tEND IF;\n\n\t-- Verify dimension\n\tIF ( (new_dim >4) OR (new_dim <2) ) THEN\n\t\tRAISE EXCEPTION 'invalid dimension';\n\t\tRETURN 'fail';\n\tEND IF;\n\n\tIF ( (new_type LIKE '%M') AND (new_dim!=3) ) THEN\n\t\tRAISE EXCEPTION 'TypeM needs 3 dimensions';\n\t\tRETURN 'fail';\n\tEND IF;\n\n\t-- Verify SRID\n\tIF ( new_srid_in > 0 ) THEN\n\t\tIF new_srid_in > 998999 THEN\n\t\t\tRAISE EXCEPTION 'AddGeometryColumn() - SRID must be <= %', 998999;\n\t\tEND IF;\n\t\tnew_srid := new_srid_in;\n\t\tSELECT SRID INTO sr FROM spatial_ref_sys WHERE SRID = new_srid;\n\t\tIF NOT FOUND THEN\n\t\t\tRAISE EXCEPTION 'AddGeometryColumn() - invalid SRID';\n\t\t\tRETURN 'fail';\n\t\tEND IF;\n\tELSE\n\t\tnew_srid := public.ST_SRID('POINT EMPTY'::public.geometry);\n\t\tIF ( new_srid_in != new_srid ) THEN\n\t\t\tRAISE NOTICE 'SRID value % converted to the officially unknown SRID value %', new_srid_in, new_srid;\n\t\tEND IF;\n\tEND IF;\n\n\t-- Verify schema\n\tIF ( schema_name IS NOT NULL AND schema_name != '' ) THEN\n\t\tsql := 'SELECT nspname FROM pg_namespace ' ||\n\t\t\t'WHERE text(nspname) = ' || quote_literal(schema_name) ||\n\t\t\t'LIMIT 1';\n\t\tRAISE DEBUG '%', sql;\n\t\tEXECUTE sql INTO real_schema;\n\n\t\tIF ( real_schema IS NULL ) THEN\n\t\t\tRAISE EXCEPTION 'Schema % is not a valid schemaname', quote_literal(schema_name);\n\t\t\tRETURN 'fail';\n\t\tEND IF;\n\tEND IF;\n\n\tIF ( real_schema IS NULL ) THEN\n\t\tRAISE DEBUG 'Detecting schema';\n\t\tsql := 'SELECT n.nspname AS schemaname ' ||\n\t\t\t'FROM pg_catalog.pg_class c ' ||\n\t\t\t  'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace ' ||\n\t\t\t'WHERE c.relkind = ' || quote_literal('r') ||\n\t\t\t' AND n.nspname NOT IN (' || quote_literal('pg_catalog') || ', ' || quote_literal('pg_toast') || ')' ||\n\t\t\t' AND pg_catalog.pg_table_is_visible(c.oid)' ||\n\t\t\t' AND c.relname = ' || quote_literal(table_name);\n\t\tRAISE DEBUG '%', sql;\n\t\tEXECUTE sql INTO real_schema;\n\n\t\tIF ( real_schema IS NULL ) THEN\n\t\t\tRAISE EXCEPTION 'Table % does not occur in the search_path', quote_literal(table_name);\n\t\t\tRETURN 'fail';\n\t\tEND IF;\n\tEND IF;\n\n\t-- Add geometry column to table\n\tIF use_typmod THEN\n\t\t sql := 'ALTER TABLE ' ||\n\t\t\tquote_ident(real_schema) || '.' || quote_ident(table_name)\n\t\t\t|| ' ADD COLUMN ' || quote_ident(column_name) ||\n\t\t\t' geometry(' || public.postgis_type_name(new_type, new_dim) || ', ' || new_srid::text || ')';\n\t\tRAISE DEBUG '%', sql;\n\tELSE\n\t\tsql := 'ALTER TABLE ' ||\n\t\t\tquote_ident(real_schema) || '.' || quote_ident(table_name)\n\t\t\t|| ' ADD COLUMN ' || quote_ident(column_name) ||\n\t\t\t' geometry ';\n\t\tRAISE DEBUG '%', sql;\n\tEND IF;\n\tEXECUTE sql;\n\n\tIF NOT use_typmod THEN\n\t\t-- Add table CHECKs\n\t\tsql := 'ALTER TABLE ' ||\n\t\t\tquote_ident(real_schema) || '.' || quote_ident(table_name)\n\t\t\t|| ' ADD CONSTRAINT '\n\t\t\t|| quote_ident('enforce_srid_' || column_name)\n\t\t\t|| ' CHECK (st_srid(' || quote_ident(column_name) ||\n\t\t\t') = ' || new_srid::text || ')' ;\n\t\tRAISE DEBUG '%', sql;\n\t\tEXECUTE sql;\n\n\t\tsql := 'ALTER TABLE ' ||\n\t\t\tquote_ident(real_schema) || '.' || quote_ident(table_name)\n\t\t\t|| ' ADD CONSTRAINT '\n\t\t\t|| quote_ident('enforce_dims_' || column_name)\n\t\t\t|| ' CHECK (st_ndims(' || quote_ident(column_name) ||\n\t\t\t') = ' || new_dim::text || ')' ;\n\t\tRAISE DEBUG '%', sql;\n\t\tEXECUTE sql;\n\n\t\tIF ( NOT (new_type = 'GEOMETRY')) THEN\n\t\t\tsql := 'ALTER TABLE ' ||\n\t\t\t\tquote_ident(real_schema) || '.' || quote_ident(table_name) || ' ADD CONSTRAINT ' ||\n\t\t\t\tquote_ident('enforce_geotype_' || column_name) ||\n\t\t\t\t' CHECK (GeometryType(' ||\n\t\t\t\tquote_ident(column_name) || ')=' ||\n\t\t\t\tquote_literal(new_type) || ' OR (' ||\n\t\t\t\tquote_ident(column_name) || ') is null)';\n\t\t\tRAISE DEBUG '%', sql;\n\t\t\tEXECUTE sql;\n\t\tEND IF;\n\tEND IF;\n\n\tRETURN\n\t\treal_schema || '.' ||\n\t\ttable_name || '.' || column_name ||\n\t\t' SRID:' || new_srid::text ||\n\t\t' TYPE:' || new_type ||\n\t\t' DIMS:' || new_dim::text || ' ';\nEND;\n$function$\n",
      "language": "plpgsql",
      "arguments": "catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true",
      "volatility": "volatile",
      "description": "args: catalog_name, schema_name, table_name, column_name, srid, type, dimension, use_typmod=true - Adds a geometry column to an existing table.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "addgeometrycolumn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.addgeometrycolumn(schema_name character varying, table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true)\n RETURNS text\n LANGUAGE plpgsql\n STABLE STRICT\nAS $function$\nDECLARE\n\tret  text;\nBEGIN\n\tSELECT public.AddGeometryColumn('',$1,$2,$3,$4,$5,$6,$7) into ret;\n\tRETURN ret;\nEND;\n$function$\n",
      "language": "plpgsql",
      "arguments": "schema_name character varying, table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true",
      "volatility": "stable",
      "description": "args: schema_name, table_name, column_name, srid, type, dimension, use_typmod=true - Adds a geometry column to an existing table.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "addgeometrycolumn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.addgeometrycolumn(table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true)\n RETURNS text\n LANGUAGE plpgsql\n STRICT\nAS $function$\nDECLARE\n\tret  text;\nBEGIN\n\tSELECT public.AddGeometryColumn('','',$1,$2,$3,$4,$5, $6) into ret;\n\tRETURN ret;\nEND;\n$function$\n",
      "language": "plpgsql",
      "arguments": "table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true",
      "volatility": "volatile",
      "description": "args: table_name, column_name, srid, type, dimension, use_typmod=true - Adds a geometry column to an existing table.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "dropgeometrycolumn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.dropgeometrycolumn(catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying)\n RETURNS text\n LANGUAGE plpgsql\n STRICT\nAS $function$\nDECLARE\n\tmyrec RECORD;\n\tokay boolean;\n\treal_schema name;\n\nBEGIN\n\n\t-- Find, check or fix schema_name\n\tIF ( schema_name != '' ) THEN\n\t\tokay = false;\n\n\t\tFOR myrec IN SELECT nspname FROM pg_namespace WHERE text(nspname) = schema_name LOOP\n\t\t\tokay := true;\n\t\tEND LOOP;\n\n\t\tIF ( okay <>  true ) THEN\n\t\t\tRAISE NOTICE 'Invalid schema name - using current_schema()';\n\t\t\tSELECT current_schema() into real_schema;\n\t\tELSE\n\t\t\treal_schema = schema_name;\n\t\tEND IF;\n\tELSE\n\t\tSELECT current_schema() into real_schema;\n\tEND IF;\n\n\t-- Find out if the column is in the geometry_columns table\n\tokay = false;\n\tFOR myrec IN SELECT * from public.geometry_columns where f_table_schema = text(real_schema) and f_table_name = table_name and f_geometry_column = column_name LOOP\n\t\tokay := true;\n\tEND LOOP;\n\tIF (okay <> true) THEN\n\t\tRAISE EXCEPTION 'column not found in geometry_columns table';\n\t\tRETURN false;\n\tEND IF;\n\n\t-- Remove table column\n\tEXECUTE 'ALTER TABLE ' || quote_ident(real_schema) || '.' ||\n\t\tquote_ident(table_name) || ' DROP COLUMN ' ||\n\t\tquote_ident(column_name);\n\n\tRETURN real_schema || '.' || table_name || '.' || column_name ||' effectively removed.';\n\nEND;\n$function$\n",
      "language": "plpgsql",
      "arguments": "catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying",
      "volatility": "volatile",
      "description": "args: catalog_name, schema_name, table_name, column_name - Removes a geometry column from a spatial table.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "dropgeometrycolumn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.dropgeometrycolumn(schema_name character varying, table_name character varying, column_name character varying)\n RETURNS text\n LANGUAGE plpgsql\n STRICT\nAS $function$\nDECLARE\n\tret text;\nBEGIN\n\tSELECT public.DropGeometryColumn('',$1,$2,$3) into ret;\n\tRETURN ret;\nEND;\n$function$\n",
      "language": "plpgsql",
      "arguments": "schema_name character varying, table_name character varying, column_name character varying",
      "volatility": "volatile",
      "description": "args: schema_name, table_name, column_name - Removes a geometry column from a spatial table.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "dropgeometrycolumn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.dropgeometrycolumn(table_name character varying, column_name character varying)\n RETURNS text\n LANGUAGE plpgsql\n STRICT\nAS $function$\nDECLARE\n\tret text;\nBEGIN\n\tSELECT public.DropGeometryColumn('','',$1,$2) into ret;\n\tRETURN ret;\nEND;\n$function$\n",
      "language": "plpgsql",
      "arguments": "table_name character varying, column_name character varying",
      "volatility": "volatile",
      "description": "args: table_name, column_name - Removes a geometry column from a spatial table.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "postgis_version",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_version()\n RETURNS text\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/postgis-3', $function$postgis_version$function$\n",
      "language": "c",
      "arguments": "",
      "volatility": "immutable",
      "description": "Returns PostGIS version number and compile-time options.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "dropgeometrytable",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.dropgeometrytable(catalog_name character varying, schema_name character varying, table_name character varying)\n RETURNS text\n LANGUAGE plpgsql\n STRICT\nAS $function$\nDECLARE\n\treal_schema name;\n\nBEGIN\n\n\tIF ( schema_name = '' ) THEN\n\t\tSELECT current_schema() into real_schema;\n\tELSE\n\t\treal_schema = schema_name;\n\tEND IF;\n\n\t-- TODO: Should we warn if table doesn't exist probably instead just saying dropped\n\t-- Remove table\n\tEXECUTE 'DROP TABLE IF EXISTS '\n\t\t|| quote_ident(real_schema) || '.' ||\n\t\tquote_ident(table_name) || ' RESTRICT';\n\n\tRETURN\n\t\treal_schema || '.' ||\n\t\ttable_name ||' dropped.';\n\nEND;\n$function$\n",
      "language": "plpgsql",
      "arguments": "catalog_name character varying, schema_name character varying, table_name character varying",
      "volatility": "volatile",
      "description": "args: catalog_name, schema_name, table_name - Drops a table and all its references in geometry_columns.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "dropgeometrytable",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.dropgeometrytable(schema_name character varying, table_name character varying)\n RETURNS text\n LANGUAGE sql\n STRICT\nAS $function$ SELECT public.DropGeometryTable('',$1,$2) $function$\n",
      "language": "sql",
      "arguments": "schema_name character varying, table_name character varying",
      "volatility": "volatile",
      "description": "args: schema_name, table_name - Drops a table and all its references in geometry_columns.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "dropgeometrytable",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.dropgeometrytable(table_name character varying)\n RETURNS text\n LANGUAGE sql\n STRICT\nAS $function$ SELECT public.DropGeometryTable('','',$1) $function$\n",
      "language": "sql",
      "arguments": "table_name character varying",
      "volatility": "volatile",
      "description": "args: table_name - Drops a table and all its references in geometry_columns.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "updategeometrysrid",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.updategeometrysrid(catalogn_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer)\n RETURNS text\n LANGUAGE plpgsql\n STRICT\nAS $function$\nDECLARE\n\tmyrec RECORD;\n\tokay boolean;\n\tcname varchar;\n\treal_schema name;\n\tunknown_srid integer;\n\tnew_srid integer := new_srid_in;\n\nBEGIN\n\n\t-- Find, check or fix schema_name\n\tIF ( schema_name != '' ) THEN\n\t\tokay = false;\n\n\t\tFOR myrec IN SELECT nspname FROM pg_namespace WHERE text(nspname) = schema_name LOOP\n\t\t\tokay := true;\n\t\tEND LOOP;\n\n\t\tIF ( okay <> true ) THEN\n\t\t\tRAISE EXCEPTION 'Invalid schema name';\n\t\tELSE\n\t\t\treal_schema = schema_name;\n\t\tEND IF;\n\tELSE\n\t\tSELECT INTO real_schema current_schema()::text;\n\tEND IF;\n\n\t-- Ensure that column_name is in geometry_columns\n\tokay = false;\n\tFOR myrec IN SELECT type, coord_dimension FROM public.geometry_columns WHERE f_table_schema = text(real_schema) and f_table_name = table_name and f_geometry_column = column_name LOOP\n\t\tokay := true;\n\tEND LOOP;\n\tIF (NOT okay) THEN\n\t\tRAISE EXCEPTION 'column not found in geometry_columns table';\n\t\tRETURN false;\n\tEND IF;\n\n\t-- Ensure that new_srid is valid\n\tIF ( new_srid > 0 ) THEN\n\t\tIF ( SELECT count(*) = 0 from spatial_ref_sys where srid = new_srid ) THEN\n\t\t\tRAISE EXCEPTION 'invalid SRID: % not found in spatial_ref_sys', new_srid;\n\t\t\tRETURN false;\n\t\tEND IF;\n\tELSE\n\t\tunknown_srid := public.ST_SRID('POINT EMPTY'::public.geometry);\n\t\tIF ( new_srid != unknown_srid ) THEN\n\t\t\tnew_srid := unknown_srid;\n\t\t\tRAISE NOTICE 'SRID value % converted to the officially unknown SRID value %', new_srid_in, new_srid;\n\t\tEND IF;\n\tEND IF;\n\n\tIF postgis_constraint_srid(real_schema, table_name, column_name) IS NOT NULL THEN\n\t-- srid was enforced with constraints before, keep it that way.\n\t\t-- Make up constraint name\n\t\tcname = 'enforce_srid_'  || column_name;\n\n\t\t-- Drop enforce_srid constraint\n\t\tEXECUTE 'ALTER TABLE ' || quote_ident(real_schema) ||\n\t\t\t'.' || quote_ident(table_name) ||\n\t\t\t' DROP constraint ' || quote_ident(cname);\n\n\t\t-- Update geometries SRID\n\t\tEXECUTE 'UPDATE ' || quote_ident(real_schema) ||\n\t\t\t'.' || quote_ident(table_name) ||\n\t\t\t' SET ' || quote_ident(column_name) ||\n\t\t\t' = public.ST_SetSRID(' || quote_ident(column_name) ||\n\t\t\t', ' || new_srid::text || ')';\n\n\t\t-- Reset enforce_srid constraint\n\t\tEXECUTE 'ALTER TABLE ' || quote_ident(real_schema) ||\n\t\t\t'.' || quote_ident(table_name) ||\n\t\t\t' ADD constraint ' || quote_ident(cname) ||\n\t\t\t' CHECK (st_srid(' || quote_ident(column_name) ||\n\t\t\t') = ' || new_srid::text || ')';\n\tELSE\n\t\t-- We will use typmod to enforce if no srid constraints\n\t\t-- We are using postgis_type_name to lookup the new name\n\t\t-- (in case Paul changes his mind and flips geometry_columns to return old upper case name)\n\t\tEXECUTE 'ALTER TABLE ' || quote_ident(real_schema) || '.' || quote_ident(table_name) ||\n\t\t' ALTER COLUMN ' || quote_ident(column_name) || ' TYPE  geometry(' || public.postgis_type_name(myrec.type, myrec.coord_dimension, true) || ', ' || new_srid::text || ') USING public.ST_SetSRID(' || quote_ident(column_name) || ',' || new_srid::text || ');' ;\n\tEND IF;\n\n\tRETURN real_schema || '.' || table_name || '.' || column_name ||' SRID changed to ' || new_srid::text;\n\nEND;\n$function$\n",
      "language": "plpgsql",
      "arguments": "catalogn_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer",
      "volatility": "volatile",
      "description": "args: catalog_name, schema_name, table_name, column_name, srid - Updates the SRID of all features in a geometry column, and the table metadata.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "updategeometrysrid",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.updategeometrysrid(character varying, character varying, character varying, integer)\n RETURNS text\n LANGUAGE plpgsql\n STRICT\nAS $function$\nDECLARE\n\tret  text;\nBEGIN\n\tSELECT public.UpdateGeometrySRID('',$1,$2,$3,$4) into ret;\n\tRETURN ret;\nEND;\n$function$\n",
      "language": "plpgsql",
      "arguments": "character varying, character varying, character varying, integer",
      "volatility": "volatile",
      "description": "args: schema_name, table_name, column_name, srid - Updates the SRID of all features in a geometry column, and the table metadata.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "updategeometrysrid",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.updategeometrysrid(character varying, character varying, integer)\n RETURNS text\n LANGUAGE plpgsql\n STRICT\nAS $function$\nDECLARE\n\tret  text;\nBEGIN\n\tSELECT public.UpdateGeometrySRID('','',$1,$2,$3) into ret;\n\tRETURN ret;\nEND;\n$function$\n",
      "language": "plpgsql",
      "arguments": "character varying, character varying, integer",
      "volatility": "volatile",
      "description": "args: table_name, column_name, srid - Updates the SRID of all features in a geometry column, and the table metadata.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "find_srid",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.find_srid(character varying, character varying, character varying)\n RETURNS integer\n LANGUAGE plpgsql\n STABLE PARALLEL SAFE STRICT\nAS $function$\nDECLARE\n\tschem varchar =  $1;\n\ttabl varchar = $2;\n\tsr int4;\nBEGIN\n-- if the table contains a . and the schema is empty\n-- split the table into a schema and a table\n-- otherwise drop through to default behavior\n\tIF ( schem = '' and strpos(tabl,'.') > 0 ) THEN\n\t schem = substr(tabl,1,strpos(tabl,'.')-1);\n\t tabl = substr(tabl,length(schem)+2);\n\tEND IF;\n\n\tselect SRID into sr from public.geometry_columns where (f_table_schema = schem or schem = '') and f_table_name = tabl and f_geometry_column = $3;\n\tIF NOT FOUND THEN\n\t   RAISE EXCEPTION 'find_srid() - could not find the corresponding SRID - is the geometry registered in the GEOMETRY_COLUMNS table?  Is there an uppercase/lowercase mismatch?';\n\tEND IF;\n\treturn sr;\nEND;\n$function$\n",
      "language": "plpgsql",
      "arguments": "character varying, character varying, character varying",
      "volatility": "stable",
      "description": "args: a_schema_name, a_table_name, a_geomfield_name - Returns the SRID defined for a geometry column.",
      "result_type": "integer",
      "security_definer": false
    },
    {
      "name": "get_proj4_from_srid",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.get_proj4_from_srid(integer)\n RETURNS text\n LANGUAGE plpgsql\n IMMUTABLE PARALLEL SAFE STRICT\nAS $function$\n\tBEGIN\n\tRETURN proj4text::text FROM public.spatial_ref_sys WHERE srid= $1;\n\tEND;\n\t$function$\n",
      "language": "plpgsql",
      "arguments": "integer",
      "volatility": "immutable",
      "description": null,
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "postgis_transform_geometry",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_transform_geometry(geom geometry, text, text, integer)\n RETURNS geometry\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 500\nAS '$libdir/postgis-3', $function$transform_geom$function$\n",
      "language": "c",
      "arguments": "geom geometry, text, text, integer",
      "volatility": "immutable",
      "description": null,
      "result_type": "geometry",
      "security_definer": false
    },
    {
      "name": "postgis_liblwgeom_version",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_liblwgeom_version()\n RETURNS text\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/postgis-3', $function$postgis_liblwgeom_version$function$\n",
      "language": "c",
      "arguments": "",
      "volatility": "immutable",
      "description": "Returns the version number of the liblwgeom library. This should match the version of PostGIS.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "postgis_proj_version",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_proj_version()\n RETURNS text\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/postgis-3', $function$postgis_proj_version$function$\n",
      "language": "c",
      "arguments": "",
      "volatility": "immutable",
      "description": "Returns the version number of the PROJ4 library.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "postgis_wagyu_version",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_wagyu_version()\n RETURNS text\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/postgis-3', $function$postgis_wagyu_version$function$\n",
      "language": "c",
      "arguments": "",
      "volatility": "immutable",
      "description": "Returns the version number of the internal Wagyu library.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "postgis_scripts_installed",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_scripts_installed()\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$ SELECT trim('3.3.2'::text || $rev$ 4975da8 $rev$) AS version $function$\n",
      "language": "sql",
      "arguments": "",
      "volatility": "immutable",
      "description": "Returns version of the PostGIS scripts installed in this database.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "postgis_lib_version",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_lib_version()\n RETURNS text\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/postgis-3', $function$postgis_lib_version$function$\n",
      "language": "c",
      "arguments": "",
      "volatility": "immutable",
      "description": "Returns the version number of the PostGIS library.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "postgis_scripts_released",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_scripts_released()\n RETURNS text\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/postgis-3', $function$postgis_scripts_released$function$\n",
      "language": "c",
      "arguments": "",
      "volatility": "immutable",
      "description": "Returns the version number of the postgis.sql script released with the installed PostGIS lib.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "postgis_geos_version",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_geos_version()\n RETURNS text\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/postgis-3', $function$postgis_geos_version$function$\n",
      "language": "c",
      "arguments": "",
      "volatility": "immutable",
      "description": "Returns the version number of the GEOS library.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "postgis_lib_revision",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_lib_revision()\n RETURNS text\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/postgis-3', $function$postgis_lib_revision$function$\n",
      "language": "c",
      "arguments": "",
      "volatility": "immutable",
      "description": null,
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "postgis_svn_version",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_svn_version()\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n\tSELECT public._postgis_deprecate(\n\t\t'postgis_svn_version', 'postgis_lib_revision', '3.1.0');\n\tSELECT public.postgis_lib_revision();\n$function$\n",
      "language": "sql",
      "arguments": "",
      "volatility": "immutable",
      "description": null,
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "postgis_libxml_version",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_libxml_version()\n RETURNS text\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/postgis-3', $function$postgis_libxml_version$function$\n",
      "language": "c",
      "arguments": "",
      "volatility": "immutable",
      "description": "Returns the version number of the libxml2 library.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "postgis_scripts_build_date",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_scripts_build_date()\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$SELECT '2022-11-13 07:09:50'::text AS version$function$\n",
      "language": "sql",
      "arguments": "",
      "volatility": "immutable",
      "description": "Returns build date of the PostGIS scripts.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "postgis_lib_build_date",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_lib_build_date()\n RETURNS text\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/postgis-3', $function$postgis_lib_build_date$function$\n",
      "language": "c",
      "arguments": "",
      "volatility": "immutable",
      "description": "Returns build date of the PostGIS library.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "_postgis_scripts_pgsql_version",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._postgis_scripts_pgsql_version()\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$SELECT '150'::text AS version$function$\n",
      "language": "sql",
      "arguments": "",
      "volatility": "immutable",
      "description": null,
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "_postgis_pgsql_version",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._postgis_pgsql_version()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\n\tSELECT CASE WHEN pg_catalog.split_part(s,'.',1)::integer > 9 THEN pg_catalog.split_part(s,'.',1) || '0'\n\tELSE pg_catalog.split_part(s,'.', 1) || pg_catalog.split_part(s,'.', 2) END AS v\n\tFROM pg_catalog.substring(version(), 'PostgreSQL ([0-9\\.]+)') AS s;\n$function$\n",
      "language": "sql",
      "arguments": "",
      "volatility": "stable",
      "description": null,
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "postgis_extensions_upgrade",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_extensions_upgrade()\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n\trec record;\n\tsql text;\n\tvar_schema text;\n\ttarget_version text; -- TODO: optionally take as argument\nBEGIN\n\n\tFOR rec IN\n\t\tSELECT name, default_version, installed_version\n\t\tFROM pg_catalog.pg_available_extensions\n\t\tWHERE name IN (\n\t\t\t'postgis',\n\t\t\t'postgis_raster',\n\t\t\t'postgis_sfcgal',\n\t\t\t'postgis_topology',\n\t\t\t'postgis_tiger_geocoder'\n\t\t)\n\t\tORDER BY length(name) -- this is to make sure 'postgis' is first !\n\tLOOP --{\n\n\t\tIF target_version IS NULL THEN\n\t\t\ttarget_version := rec.default_version;\n\t\tEND IF;\n\n\t\tIF rec.installed_version IS NULL THEN --{\n\t\t\t-- If the support installed by available extension\n\t\t\t-- is found unpackaged, we package it\n\t\t\tIF --{\n\t\t\t\t -- PostGIS is always available (this function is part of it)\n\t\t\t\t rec.name = 'postgis'\n\n\t\t\t\t -- PostGIS raster is available if type 'raster' exists\n\t\t\t\t OR ( rec.name = 'postgis_raster' AND EXISTS (\n\t\t\t\t\t\t\tSELECT 1 FROM pg_catalog.pg_type\n\t\t\t\t\t\t\tWHERE typname = 'raster' ) )\n\n\t\t\t\t -- PostGIS SFCGAL is availble if\n\t\t\t\t -- 'postgis_sfcgal_version' function exists\n\t\t\t\t OR ( rec.name = 'postgis_sfcgal' AND EXISTS (\n\t\t\t\t\t\t\tSELECT 1 FROM pg_catalog.pg_proc\n\t\t\t\t\t\t\tWHERE proname = 'postgis_sfcgal_version' ) )\n\n\t\t\t\t -- PostGIS Topology is available if\n\t\t\t\t -- 'topology.topology' table exists\n\t\t\t\t -- NOTE: watch out for https://trac.osgeo.org/postgis/ticket/2503\n\t\t\t\t OR ( rec.name = 'postgis_topology' AND EXISTS (\n\t\t\t\t\t\t\tSELECT 1 FROM pg_catalog.pg_class c\n\t\t\t\t\t\t\tJOIN pg_catalog.pg_namespace n ON (c.relnamespace = n.oid )\n\t\t\t\t\t\t\tWHERE n.nspname = 'topology' AND c.relname = 'topology') )\n\n\t\t\t\t OR ( rec.name = 'postgis_tiger_geocoder' AND EXISTS (\n\t\t\t\t\t\t\tSELECT 1 FROM pg_catalog.pg_class c\n\t\t\t\t\t\t\tJOIN pg_catalog.pg_namespace n ON (c.relnamespace = n.oid )\n\t\t\t\t\t\t\tWHERE n.nspname = 'tiger' AND c.relname = 'geocode_settings') )\n\t\t\tTHEN --}{\n\t\t\t\t-- Force install in same schema as postgis\n\t\t\t\tSELECT INTO var_schema n.nspname\n\t\t\t\t  FROM pg_namespace n, pg_proc p\n\t\t\t\t  WHERE p.proname = 'postgis_full_version'\n\t\t\t\t\tAND n.oid = p.pronamespace\n\t\t\t\t  LIMIT 1;\n\t\t\t\tIF rec.name NOT IN('postgis_topology', 'postgis_tiger_geocoder')\n\t\t\t\tTHEN\n\t\t\t\t\tsql := format(\n\t\t\t\t\t\t\t  'CREATE EXTENSION %1$I SCHEMA %2$I VERSION unpackaged;'\n\t\t\t\t\t\t\t  'ALTER EXTENSION %1$I UPDATE TO %3$I',\n\t\t\t\t\t\t\t  rec.name, var_schema, target_version);\n\t\t\t\tELSE\n\t\t\t\t\tsql := format(\n\t\t\t\t\t\t\t 'CREATE EXTENSION %1$I VERSION unpackaged;'\n\t\t\t\t\t\t\t 'ALTER EXTENSION %1$I UPDATE TO %2$I',\n\t\t\t\t\t\t\t rec.name, target_version);\n\t\t\t\tEND IF;\n\t\t\t\tRAISE NOTICE 'Packaging and updating %', rec.name;\n\t\t\t\tRAISE DEBUG '%', sql;\n\t\t\t\tEXECUTE sql;\n\t\t\tELSE\n\t\t\t\tRAISE DEBUG 'Skipping % (not in use)', rec.name;\n\t\t\tEND IF;\n\t\tELSE -- IF target_version != rec.installed_version THEN --}{\n\t\t\tsql = '';\n\t\t\t-- If logged in as super user\n\t\t\t-- force an update regardless if at target version, no downgrade allowed\n\t\t\tIF (SELECT usesuper FROM pg_user WHERE usename = CURRENT_USER)\n\t\t\t\t\t\tAND pg_catalog.substring(target_version, '[0-9]+\\.[0-9]+\\.[0-9]+')\n\t\t\t\t\t\t\t\t>= pg_catalog.substring(rec.installed_version, '[0-9]+\\.[0-9]+\\.[0-9]+')\n\t\t\tTHEN\n\t\t\t\tsql = format(\n\t\t\t\t\t'UPDATE pg_catalog.pg_extension SET extversion = ''ANY'' WHERE extname = %1$L;'\n\t\t\t\t\t'ALTER EXTENSION %1$I UPDATE TO %2$I',\n\t\t\t\t\trec.name, target_version\n\t\t\t\t);\n\t\t\t-- sandboxed users do standard upgrade\n\t\t\tELSE\n\t\t\t\tsql = format(\n\t\t\t\t'ALTER EXTENSION %1$I UPDATE TO %2$I',\n\t\t\t\trec.name, target_version\n\t\t\t\t);\n\t\t\tEND IF;\n\t\t\tRAISE NOTICE 'Updating extension % %',\n\t\t\t\trec.name, rec.installed_version;\n\t\t\tRAISE DEBUG '%', sql;\n\t\t\tEXECUTE sql;\n\t\tEND IF; --}\n\n\tEND LOOP; --}\n\n\tRETURN format(\n\t\t'Upgrade to version %s completed, run SELECT postgis_full_version(); for details',\n\t\ttarget_version\n\t);\n\n\nEND\n$function$\n",
      "language": "plpgsql",
      "arguments": "",
      "volatility": "volatile",
      "description": "Packages and upgrades PostGIS extensions (e.g. postgis_raster,postgis_topology, postgis_sfcgal) to latest available version.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "postgis_full_version",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_full_version()\n RETURNS text\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nDECLARE\n\tlibver text;\n\tlibrev text;\n\tprojver text;\n\tgeosver text;\n\tsfcgalver text;\n\tgdalver text := NULL;\n\tlibxmlver text;\n\tliblwgeomver text;\n\tdbproc text;\n\trelproc text;\n\tfullver text;\n\trast_lib_ver text := NULL;\n\trast_scr_ver text := NULL;\n\ttopo_scr_ver text := NULL;\n\tjson_lib_ver text;\n\tprotobuf_lib_ver text;\n\twagyu_lib_ver text;\n\tsfcgal_lib_ver text;\n\tsfcgal_scr_ver text;\n\tpgsql_scr_ver text;\n\tpgsql_ver text;\n\tcore_is_extension bool;\nBEGIN\n\tSELECT public.postgis_lib_version() INTO libver;\n\tSELECT public.postgis_proj_version() INTO projver;\n\tSELECT public.postgis_geos_version() INTO geosver;\n\tSELECT public.postgis_libjson_version() INTO json_lib_ver;\n\tSELECT public.postgis_libprotobuf_version() INTO protobuf_lib_ver;\n\tSELECT public.postgis_wagyu_version() INTO wagyu_lib_ver;\n\tSELECT public._postgis_scripts_pgsql_version() INTO pgsql_scr_ver;\n\tSELECT public._postgis_pgsql_version() INTO pgsql_ver;\n\tBEGIN\n\t\tSELECT public.postgis_gdal_version() INTO gdalver;\n\tEXCEPTION\n\t\tWHEN undefined_function THEN\n\t\t\tRAISE DEBUG 'Function postgis_gdal_version() not found.  Is raster support enabled and rtpostgis.sql installed?';\n\tEND;\n\tBEGIN\n\t\tSELECT public.postgis_sfcgal_full_version() INTO sfcgalver;\n\t\tBEGIN\n\t\t\tSELECT public.postgis_sfcgal_scripts_installed() INTO sfcgal_scr_ver;\n\t\tEXCEPTION\n\t\t\tWHEN undefined_function THEN\n\t\t\t\tsfcgal_scr_ver := 'missing';\n\t\tEND;\n\tEXCEPTION\n\t\tWHEN undefined_function THEN\n\t\t\tRAISE DEBUG 'Function postgis_sfcgal_scripts_installed() not found. Is sfcgal support enabled and sfcgal.sql installed?';\n\tEND;\n\tSELECT public.postgis_liblwgeom_version() INTO liblwgeomver;\n\tSELECT public.postgis_libxml_version() INTO libxmlver;\n\tSELECT public.postgis_scripts_installed() INTO dbproc;\n\tSELECT public.postgis_scripts_released() INTO relproc;\n\tSELECT public.postgis_lib_revision() INTO librev;\n\tBEGIN\n\t\tSELECT topology.postgis_topology_scripts_installed() INTO topo_scr_ver;\n\tEXCEPTION\n\t\tWHEN undefined_function OR invalid_schema_name THEN\n\t\t\tRAISE DEBUG 'Function postgis_topology_scripts_installed() not found. Is topology support enabled and topology.sql installed?';\n\t\tWHEN insufficient_privilege THEN\n\t\t\tRAISE NOTICE 'Topology support cannot be inspected. Is current user granted USAGE on schema \"topology\" ?';\n\t\tWHEN OTHERS THEN\n\t\t\tRAISE NOTICE 'Function postgis_topology_scripts_installed() could not be called: % (%)', SQLERRM, SQLSTATE;\n\tEND;\n\n\tBEGIN\n\t\tSELECT postgis_raster_scripts_installed() INTO rast_scr_ver;\n\tEXCEPTION\n\t\tWHEN undefined_function THEN\n\t\t\tRAISE DEBUG 'Function postgis_raster_scripts_installed() not found. Is raster support enabled and rtpostgis.sql installed?';\n\t\tWHEN OTHERS THEN\n\t\t\tRAISE NOTICE 'Function postgis_raster_scripts_installed() could not be called: % (%)', SQLERRM, SQLSTATE;\n\tEND;\n\n\tBEGIN\n\t\tSELECT public.postgis_raster_lib_version() INTO rast_lib_ver;\n\tEXCEPTION\n\t\tWHEN undefined_function THEN\n\t\t\tRAISE DEBUG 'Function postgis_raster_lib_version() not found. Is raster support enabled and rtpostgis.sql installed?';\n\t\tWHEN OTHERS THEN\n\t\t\tRAISE NOTICE 'Function postgis_raster_lib_version() could not be called: % (%)', SQLERRM, SQLSTATE;\n\tEND;\n\n\tfullver = 'POSTGIS=\"' || libver;\n\n\tIF  librev IS NOT NULL THEN\n\t\tfullver = fullver || ' ' || librev;\n\tEND IF;\n\n\tfullver = fullver || '\"';\n\n\tIF EXISTS (\n\t\tSELECT * FROM pg_catalog.pg_extension\n\t\tWHERE extname = 'postgis')\n\tTHEN\n\t\t\tfullver = fullver || ' [EXTENSION]';\n\t\t\tcore_is_extension := true;\n\tELSE\n\t\t\tcore_is_extension := false;\n\tEND IF;\n\n\tIF liblwgeomver != relproc THEN\n\t\tfullver = fullver || ' (liblwgeom version mismatch: \"' || liblwgeomver || '\")';\n\tEND IF;\n\n\tfullver = fullver || ' PGSQL=\"' || pgsql_scr_ver || '\"';\n\tIF pgsql_scr_ver != pgsql_ver THEN\n\t\tfullver = fullver || ' (procs need upgrade for use with PostgreSQL \"' || pgsql_ver || '\")';\n\tEND IF;\n\n\tIF  geosver IS NOT NULL THEN\n\t\tfullver = fullver || ' GEOS=\"' || geosver || '\"';\n\tEND IF;\n\n\tIF  sfcgalver IS NOT NULL THEN\n\t\tfullver = fullver || ' SFCGAL=\"' || sfcgalver || '\"';\n\tEND IF;\n\n\tIF  projver IS NOT NULL THEN\n\t\tfullver = fullver || ' PROJ=\"' || projver || '\"';\n\tEND IF;\n\n\tIF  gdalver IS NOT NULL THEN\n\t\tfullver = fullver || ' GDAL=\"' || gdalver || '\"';\n\tEND IF;\n\n\tIF  libxmlver IS NOT NULL THEN\n\t\tfullver = fullver || ' LIBXML=\"' || libxmlver || '\"';\n\tEND IF;\n\n\tIF json_lib_ver IS NOT NULL THEN\n\t\tfullver = fullver || ' LIBJSON=\"' || json_lib_ver || '\"';\n\tEND IF;\n\n\tIF protobuf_lib_ver IS NOT NULL THEN\n\t\tfullver = fullver || ' LIBPROTOBUF=\"' || protobuf_lib_ver || '\"';\n\tEND IF;\n\n\tIF wagyu_lib_ver IS NOT NULL THEN\n\t\tfullver = fullver || ' WAGYU=\"' || wagyu_lib_ver || '\"';\n\tEND IF;\n\n\tIF dbproc != relproc THEN\n\t\tfullver = fullver || ' (core procs from \"' || dbproc || '\" need upgrade)';\n\tEND IF;\n\n\tIF topo_scr_ver IS NOT NULL THEN\n\t\tfullver = fullver || ' TOPOLOGY';\n\t\tIF topo_scr_ver != relproc THEN\n\t\t\tfullver = fullver || ' (topology procs from \"' || topo_scr_ver || '\" need upgrade)';\n\t\tEND IF;\n\t\tIF core_is_extension AND NOT EXISTS (\n\t\t\tSELECT * FROM pg_catalog.pg_extension\n\t\t\tWHERE extname = 'postgis_topology')\n\t\tTHEN\n\t\t\t\tfullver = fullver || ' [UNPACKAGED!]';\n\t\tEND IF;\n\tEND IF;\n\n\tIF rast_lib_ver IS NOT NULL THEN\n\t\tfullver = fullver || ' RASTER';\n\t\tIF rast_lib_ver != relproc THEN\n\t\t\tfullver = fullver || ' (raster lib from \"' || rast_lib_ver || '\" need upgrade)';\n\t\tEND IF;\n\t\tIF core_is_extension AND NOT EXISTS (\n\t\t\tSELECT * FROM pg_catalog.pg_extension\n\t\t\tWHERE extname = 'postgis_raster')\n\t\tTHEN\n\t\t\t\tfullver = fullver || ' [UNPACKAGED!]';\n\t\tEND IF;\n\tEND IF;\n\n\tIF rast_scr_ver IS NOT NULL AND rast_scr_ver != relproc THEN\n\t\tfullver = fullver || ' (raster procs from \"' || rast_scr_ver || '\" need upgrade)';\n\tEND IF;\n\n\tIF sfcgal_scr_ver IS NOT NULL AND sfcgal_scr_ver != relproc THEN\n\t\tfullver = fullver || ' (sfcgal procs from \"' || sfcgal_scr_ver || '\" need upgrade)';\n\tEND IF;\n\n\t-- Check for the presence of deprecated functions\n\tIF EXISTS ( SELECT oid FROM pg_catalog.pg_proc WHERE proname LIKE '%_deprecated_by_postgis_%' )\n\tTHEN\n\t\tfullver = fullver || ' (deprecated functions exist, upgrade is not complete)';\n\tEND IF;\n\n\tRETURN fullver;\nEND\n$function$\n",
      "language": "plpgsql",
      "arguments": "",
      "volatility": "immutable",
      "description": "Reports full PostGIS version and build configuration infos.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "box2d",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.box2d(geometry)\n RETURNS box2d\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 50\nAS '$libdir/postgis-3', $function$LWGEOM_to_BOX2D$function$\n",
      "language": "c",
      "arguments": "geometry",
      "volatility": "immutable",
      "description": "args: geom - Returns a BOX2D representing the 2D extent of a geometry.",
      "result_type": "box2d",
      "security_definer": false
    },
    {
      "name": "box3d",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.box3d(geometry)\n RETURNS box3d\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 50\nAS '$libdir/postgis-3', $function$LWGEOM_to_BOX3D$function$\n",
      "language": "c",
      "arguments": "geometry",
      "volatility": "immutable",
      "description": "args: geom - Returns a BOX3D representing the 3D extent of a geometry.",
      "result_type": "box3d",
      "security_definer": false
    },
    {
      "name": "box",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.box(geometry)\n RETURNS box\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 50\nAS '$libdir/postgis-3', $function$LWGEOM_to_BOX$function$\n",
      "language": "c",
      "arguments": "geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "box",
      "security_definer": false
    },
    {
      "name": "box2d",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.box2d(box3d)\n RETURNS box2d\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 50\nAS '$libdir/postgis-3', $function$BOX3D_to_BOX2D$function$\n",
      "language": "c",
      "arguments": "box3d",
      "volatility": "immutable",
      "description": null,
      "result_type": "box2d",
      "security_definer": false
    },
    {
      "name": "box3d",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.box3d(box2d)\n RETURNS box3d\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 50\nAS '$libdir/postgis-3', $function$BOX2D_to_BOX3D$function$\n",
      "language": "c",
      "arguments": "box2d",
      "volatility": "immutable",
      "description": null,
      "result_type": "box3d",
      "security_definer": false
    },
    {
      "name": "box",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.box(box3d)\n RETURNS box\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 50\nAS '$libdir/postgis-3', $function$BOX3D_to_BOX$function$\n",
      "language": "c",
      "arguments": "box3d",
      "volatility": "immutable",
      "description": null,
      "result_type": "box",
      "security_definer": false
    },
    {
      "name": "text",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.text(geometry)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 50\nAS '$libdir/postgis-3', $function$LWGEOM_to_text$function$\n",
      "language": "c",
      "arguments": "geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "box3dtobox",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.box3dtobox(box3d)\n RETURNS box\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 50\nAS '$libdir/postgis-3', $function$BOX3D_to_BOX$function$\n",
      "language": "c",
      "arguments": "box3d",
      "volatility": "immutable",
      "description": null,
      "result_type": "box",
      "security_definer": false
    },
    {
      "name": "geometry",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.geometry(box2d)\n RETURNS geometry\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 50\nAS '$libdir/postgis-3', $function$BOX2D_to_LWGEOM$function$\n",
      "language": "c",
      "arguments": "box2d",
      "volatility": "immutable",
      "description": null,
      "result_type": "geometry",
      "security_definer": false
    },
    {
      "name": "geometry",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.geometry(box3d)\n RETURNS geometry\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 50\nAS '$libdir/postgis-3', $function$BOX3D_to_LWGEOM$function$\n",
      "language": "c",
      "arguments": "box3d",
      "volatility": "immutable",
      "description": null,
      "result_type": "geometry",
      "security_definer": false
    },
    {
      "name": "geometry",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.geometry(text)\n RETURNS geometry\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 50\nAS '$libdir/postgis-3', $function$parse_WKT_lwgeom$function$\n",
      "language": "c",
      "arguments": "text",
      "volatility": "immutable",
      "description": null,
      "result_type": "geometry",
      "security_definer": false
    },
    {
      "name": "geometry",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.geometry(bytea)\n RETURNS geometry\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 50\nAS '$libdir/postgis-3', $function$LWGEOM_from_bytea$function$\n",
      "language": "c",
      "arguments": "bytea",
      "volatility": "immutable",
      "description": null,
      "result_type": "geometry",
      "security_definer": false
    },
    {
      "name": "bytea",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.bytea(geometry)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 50\nAS '$libdir/postgis-3', $function$LWGEOM_to_bytea$function$\n",
      "language": "c",
      "arguments": "geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "bytea",
      "security_definer": false
    },
    {
      "name": "_st_voronoi",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_voronoi(g1 geometry, clip geometry DEFAULT NULL::geometry, tolerance double precision DEFAULT 0.0, return_polygons boolean DEFAULT true)\n RETURNS geometry\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE COST 10000\nAS '$libdir/postgis-3', $function$ST_Voronoi$function$\n",
      "language": "c",
      "arguments": "g1 geometry, clip geometry DEFAULT NULL::geometry, tolerance double precision DEFAULT 0.0, return_polygons boolean DEFAULT true",
      "volatility": "immutable",
      "description": null,
      "result_type": "geometry",
      "security_definer": false
    },
    {
      "name": "pgis_geometry_accum_transfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_geometry_accum_transfn(internal, geometry)\n RETURNS internal\n LANGUAGE c\n PARALLEL SAFE COST 50\nAS '$libdir/postgis-3', $function$pgis_geometry_accum_transfn$function$\n",
      "language": "c",
      "arguments": "internal, geometry",
      "volatility": "volatile",
      "description": null,
      "result_type": "internal",
      "security_definer": false
    },
    {
      "name": "pgis_geometry_accum_transfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_geometry_accum_transfn(internal, geometry, double precision)\n RETURNS internal\n LANGUAGE c\n PARALLEL SAFE COST 50\nAS '$libdir/postgis-3', $function$pgis_geometry_accum_transfn$function$\n",
      "language": "c",
      "arguments": "internal, geometry, double precision",
      "volatility": "volatile",
      "description": null,
      "result_type": "internal",
      "security_definer": false
    },
    {
      "name": "pgis_geometry_accum_transfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_geometry_accum_transfn(internal, geometry, double precision, integer)\n RETURNS internal\n LANGUAGE c\n PARALLEL SAFE COST 50\nAS '$libdir/postgis-3', $function$pgis_geometry_accum_transfn$function$\n",
      "language": "c",
      "arguments": "internal, geometry, double precision, integer",
      "volatility": "volatile",
      "description": null,
      "result_type": "internal",
      "security_definer": false
    },
    {
      "name": "pgis_geometry_collect_finalfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_geometry_collect_finalfn(internal)\n RETURNS geometry\n LANGUAGE c\n PARALLEL SAFE COST 500\nAS '$libdir/postgis-3', $function$pgis_geometry_collect_finalfn$function$\n",
      "language": "c",
      "arguments": "internal",
      "volatility": "volatile",
      "description": null,
      "result_type": "geometry",
      "security_definer": false
    },
    {
      "name": "pgis_geometry_polygonize_finalfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_geometry_polygonize_finalfn(internal)\n RETURNS geometry\n LANGUAGE c\n PARALLEL SAFE COST 500\nAS '$libdir/postgis-3', $function$pgis_geometry_polygonize_finalfn$function$\n",
      "language": "c",
      "arguments": "internal",
      "volatility": "volatile",
      "description": null,
      "result_type": "geometry",
      "security_definer": false
    },
    {
      "name": "pgis_geometry_clusterintersecting_finalfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_geometry_clusterintersecting_finalfn(internal)\n RETURNS geometry[]\n LANGUAGE c\n PARALLEL SAFE COST 500\nAS '$libdir/postgis-3', $function$pgis_geometry_clusterintersecting_finalfn$function$\n",
      "language": "c",
      "arguments": "internal",
      "volatility": "volatile",
      "description": null,
      "result_type": "geometry[]",
      "security_definer": false
    },
    {
      "name": "pgis_geometry_clusterwithin_finalfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_geometry_clusterwithin_finalfn(internal)\n RETURNS geometry[]\n LANGUAGE c\n PARALLEL SAFE COST 500\nAS '$libdir/postgis-3', $function$pgis_geometry_clusterwithin_finalfn$function$\n",
      "language": "c",
      "arguments": "internal",
      "volatility": "volatile",
      "description": null,
      "result_type": "geometry[]",
      "security_definer": false
    },
    {
      "name": "pgis_geometry_makeline_finalfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_geometry_makeline_finalfn(internal)\n RETURNS geometry\n LANGUAGE c\n PARALLEL SAFE COST 500\nAS '$libdir/postgis-3', $function$pgis_geometry_makeline_finalfn$function$\n",
      "language": "c",
      "arguments": "internal",
      "volatility": "volatile",
      "description": null,
      "result_type": "geometry",
      "security_definer": false
    },
    {
      "name": "pgis_geometry_union_parallel_transfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_geometry_union_parallel_transfn(internal, geometry)\n RETURNS internal\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE\nAS '$libdir/postgis-3', $function$pgis_geometry_union_parallel_transfn$function$\n",
      "language": "c",
      "arguments": "internal, geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "internal",
      "security_definer": false
    },
    {
      "name": "pgis_geometry_union_parallel_transfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_geometry_union_parallel_transfn(internal, geometry, double precision)\n RETURNS internal\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE COST 50\nAS '$libdir/postgis-3', $function$pgis_geometry_union_parallel_transfn$function$\n",
      "language": "c",
      "arguments": "internal, geometry, double precision",
      "volatility": "immutable",
      "description": null,
      "result_type": "internal",
      "security_definer": false
    },
    {
      "name": "pgis_geometry_union_parallel_combinefn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_geometry_union_parallel_combinefn(internal, internal)\n RETURNS internal\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE\nAS '$libdir/postgis-3', $function$pgis_geometry_union_parallel_combinefn$function$\n",
      "language": "c",
      "arguments": "internal, internal",
      "volatility": "immutable",
      "description": null,
      "result_type": "internal",
      "security_definer": false
    },
    {
      "name": "pgis_geometry_union_parallel_serialfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_geometry_union_parallel_serialfn(internal)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$pgis_geometry_union_parallel_serialfn$function$\n",
      "language": "c",
      "arguments": "internal",
      "volatility": "immutable",
      "description": null,
      "result_type": "bytea",
      "security_definer": false
    },
    {
      "name": "pgis_geometry_union_parallel_deserialfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_geometry_union_parallel_deserialfn(bytea, internal)\n RETURNS internal\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$pgis_geometry_union_parallel_deserialfn$function$\n",
      "language": "c",
      "arguments": "bytea, internal",
      "volatility": "immutable",
      "description": null,
      "result_type": "internal",
      "security_definer": false
    },
    {
      "name": "pgis_geometry_union_parallel_finalfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_geometry_union_parallel_finalfn(internal)\n RETURNS geometry\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 10000\nAS '$libdir/postgis-3', $function$pgis_geometry_union_parallel_finalfn$function$\n",
      "language": "c",
      "arguments": "internal",
      "volatility": "immutable",
      "description": null,
      "result_type": "geometry",
      "security_definer": false
    },
    {
      "name": "_st_linecrossingdirection",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_linecrossingdirection(line1 geometry, line2 geometry)\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 10000\nAS '$libdir/postgis-3', $function$ST_LineCrossingDirection$function$\n",
      "language": "c",
      "arguments": "line1 geometry, line2 geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "integer",
      "security_definer": false
    },
    {
      "name": "_st_dwithin",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_dwithin(geom1 geometry, geom2 geometry, double precision)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 10000\nAS '$libdir/postgis-3', $function$LWGEOM_dwithin$function$\n",
      "language": "c",
      "arguments": "geom1 geometry, geom2 geometry, double precision",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "_st_touches",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_touches(geom1 geometry, geom2 geometry)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 10000\nAS '$libdir/postgis-3', $function$touches$function$\n",
      "language": "c",
      "arguments": "geom1 geometry, geom2 geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "_st_intersects",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_intersects(geom1 geometry, geom2 geometry)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 10000\nAS '$libdir/postgis-3', $function$ST_Intersects$function$\n",
      "language": "c",
      "arguments": "geom1 geometry, geom2 geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "_st_crosses",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_crosses(geom1 geometry, geom2 geometry)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 10000\nAS '$libdir/postgis-3', $function$crosses$function$\n",
      "language": "c",
      "arguments": "geom1 geometry, geom2 geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "_st_contains",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_contains(geom1 geometry, geom2 geometry)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 10000\nAS '$libdir/postgis-3', $function$contains$function$\n",
      "language": "c",
      "arguments": "geom1 geometry, geom2 geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "_st_containsproperly",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_containsproperly(geom1 geometry, geom2 geometry)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 10000\nAS '$libdir/postgis-3', $function$containsproperly$function$\n",
      "language": "c",
      "arguments": "geom1 geometry, geom2 geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "_st_covers",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_covers(geom1 geometry, geom2 geometry)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 10000\nAS '$libdir/postgis-3', $function$covers$function$\n",
      "language": "c",
      "arguments": "geom1 geometry, geom2 geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "_st_coveredby",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_coveredby(geom1 geometry, geom2 geometry)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 10000\nAS '$libdir/postgis-3', $function$coveredby$function$\n",
      "language": "c",
      "arguments": "geom1 geometry, geom2 geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "_st_within",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_within(geom1 geometry, geom2 geometry)\n RETURNS boolean\n LANGUAGE sql\n IMMUTABLE PARALLEL SAFE\nAS $function$SELECT public._ST_Contains($2,$1)$function$\n",
      "language": "sql",
      "arguments": "geom1 geometry, geom2 geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "_st_overlaps",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_overlaps(geom1 geometry, geom2 geometry)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 10000\nAS '$libdir/postgis-3', $function$overlaps$function$\n",
      "language": "c",
      "arguments": "geom1 geometry, geom2 geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "_st_dfullywithin",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_dfullywithin(geom1 geometry, geom2 geometry, double precision)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 10000\nAS '$libdir/postgis-3', $function$LWGEOM_dfullywithin$function$\n",
      "language": "c",
      "arguments": "geom1 geometry, geom2 geometry, double precision",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "_st_3ddwithin",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_3ddwithin(geom1 geometry, geom2 geometry, double precision)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 10000\nAS '$libdir/postgis-3', $function$LWGEOM_dwithin3d$function$\n",
      "language": "c",
      "arguments": "geom1 geometry, geom2 geometry, double precision",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "_st_3ddfullywithin",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_3ddfullywithin(geom1 geometry, geom2 geometry, double precision)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 10000\nAS '$libdir/postgis-3', $function$LWGEOM_dfullywithin3d$function$\n",
      "language": "c",
      "arguments": "geom1 geometry, geom2 geometry, double precision",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "_st_3dintersects",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_3dintersects(geom1 geometry, geom2 geometry)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 10000\nAS '$libdir/postgis-3', $function$ST_3DIntersects$function$\n",
      "language": "c",
      "arguments": "geom1 geometry, geom2 geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "_st_orderingequals",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_orderingequals(geom1 geometry, geom2 geometry)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 10000\nAS '$libdir/postgis-3', $function$LWGEOM_same$function$\n",
      "language": "c",
      "arguments": "geom1 geometry, geom2 geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "_st_equals",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_equals(geom1 geometry, geom2 geometry)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 10000\nAS '$libdir/postgis-3', $function$ST_Equals$function$\n",
      "language": "c",
      "arguments": "geom1 geometry, geom2 geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "postgis_index_supportfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_index_supportfn(internal)\n RETURNS internal\n LANGUAGE c\nAS '$libdir/postgis-3', $function$postgis_index_supportfn$function$\n",
      "language": "c",
      "arguments": "internal",
      "volatility": "volatile",
      "description": null,
      "result_type": "internal",
      "security_definer": false
    },
    {
      "name": "equals",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.equals(geom1 geometry, geom2 geometry)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 500\nAS '$libdir/postgis-3', $function$ST_Equals$function$\n",
      "language": "c",
      "arguments": "geom1 geometry, geom2 geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "_st_geomfromgml",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_geomfromgml(text, integer)\n RETURNS geometry\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE COST 500\nAS '$libdir/postgis-3', $function$geom_from_gml$function$\n",
      "language": "c",
      "arguments": "text, integer",
      "volatility": "immutable",
      "description": null,
      "result_type": "geometry",
      "security_definer": false
    },
    {
      "name": "postgis_libjson_version",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_libjson_version()\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$postgis_libjson_version$function$\n",
      "language": "c",
      "arguments": "",
      "volatility": "immutable",
      "description": null,
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "_st_asgml",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_asgml(integer, geometry, integer, integer, text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE COST 500\nAS '$libdir/postgis-3', $function$LWGEOM_asGML$function$\n",
      "language": "c",
      "arguments": "integer, geometry, integer, integer, text, text",
      "volatility": "immutable",
      "description": null,
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "json",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.json(geometry)\n RETURNS json\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 500\nAS '$libdir/postgis-3', $function$geometry_to_json$function$\n",
      "language": "c",
      "arguments": "geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "json",
      "security_definer": false
    },
    {
      "name": "jsonb",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.jsonb(geometry)\n RETURNS jsonb\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 500\nAS '$libdir/postgis-3', $function$geometry_to_jsonb$function$\n",
      "language": "c",
      "arguments": "geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "jsonb",
      "security_definer": false
    },
    {
      "name": "pgis_asmvt_transfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_asmvt_transfn(internal, anyelement)\n RETURNS internal\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE COST 500\nAS '$libdir/postgis-3', $function$pgis_asmvt_transfn$function$\n",
      "language": "c",
      "arguments": "internal, anyelement",
      "volatility": "immutable",
      "description": null,
      "result_type": "internal",
      "security_definer": false
    },
    {
      "name": "pgis_asmvt_transfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_asmvt_transfn(internal, anyelement, text)\n RETURNS internal\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE COST 500\nAS '$libdir/postgis-3', $function$pgis_asmvt_transfn$function$\n",
      "language": "c",
      "arguments": "internal, anyelement, text",
      "volatility": "immutable",
      "description": null,
      "result_type": "internal",
      "security_definer": false
    },
    {
      "name": "pgis_asmvt_transfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_asmvt_transfn(internal, anyelement, text, integer)\n RETURNS internal\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE COST 500\nAS '$libdir/postgis-3', $function$pgis_asmvt_transfn$function$\n",
      "language": "c",
      "arguments": "internal, anyelement, text, integer",
      "volatility": "immutable",
      "description": null,
      "result_type": "internal",
      "security_definer": false
    },
    {
      "name": "pgis_asmvt_transfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_asmvt_transfn(internal, anyelement, text, integer, text)\n RETURNS internal\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE COST 500\nAS '$libdir/postgis-3', $function$pgis_asmvt_transfn$function$\n",
      "language": "c",
      "arguments": "internal, anyelement, text, integer, text",
      "volatility": "immutable",
      "description": null,
      "result_type": "internal",
      "security_definer": false
    },
    {
      "name": "pgis_asmvt_transfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_asmvt_transfn(internal, anyelement, text, integer, text, text)\n RETURNS internal\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE COST 500\nAS '$libdir/postgis-3', $function$pgis_asmvt_transfn$function$\n",
      "language": "c",
      "arguments": "internal, anyelement, text, integer, text, text",
      "volatility": "immutable",
      "description": null,
      "result_type": "internal",
      "security_definer": false
    },
    {
      "name": "pgis_asmvt_finalfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_asmvt_finalfn(internal)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE COST 500\nAS '$libdir/postgis-3', $function$pgis_asmvt_finalfn$function$\n",
      "language": "c",
      "arguments": "internal",
      "volatility": "immutable",
      "description": null,
      "result_type": "bytea",
      "security_definer": false
    },
    {
      "name": "pgis_asmvt_combinefn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_asmvt_combinefn(internal, internal)\n RETURNS internal\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE COST 500\nAS '$libdir/postgis-3', $function$pgis_asmvt_combinefn$function$\n",
      "language": "c",
      "arguments": "internal, internal",
      "volatility": "immutable",
      "description": null,
      "result_type": "internal",
      "security_definer": false
    },
    {
      "name": "pgis_asmvt_serialfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_asmvt_serialfn(internal)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE COST 500\nAS '$libdir/postgis-3', $function$pgis_asmvt_serialfn$function$\n",
      "language": "c",
      "arguments": "internal",
      "volatility": "immutable",
      "description": null,
      "result_type": "bytea",
      "security_definer": false
    },
    {
      "name": "pgis_asmvt_deserialfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_asmvt_deserialfn(bytea, internal)\n RETURNS internal\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE COST 500\nAS '$libdir/postgis-3', $function$pgis_asmvt_deserialfn$function$\n",
      "language": "c",
      "arguments": "bytea, internal",
      "volatility": "immutable",
      "description": null,
      "result_type": "internal",
      "security_definer": false
    },
    {
      "name": "postgis_libprotobuf_version",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_libprotobuf_version()\n RETURNS text\n LANGUAGE c\n IMMUTABLE STRICT\nAS '$libdir/postgis-3', $function$postgis_libprotobuf_version$function$\n",
      "language": "c",
      "arguments": "",
      "volatility": "immutable",
      "description": null,
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "pgis_asgeobuf_transfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_asgeobuf_transfn(internal, anyelement)\n RETURNS internal\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE COST 50\nAS '$libdir/postgis-3', $function$pgis_asgeobuf_transfn$function$\n",
      "language": "c",
      "arguments": "internal, anyelement",
      "volatility": "immutable",
      "description": null,
      "result_type": "internal",
      "security_definer": false
    },
    {
      "name": "pgis_asgeobuf_transfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_asgeobuf_transfn(internal, anyelement, text)\n RETURNS internal\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE COST 50\nAS '$libdir/postgis-3', $function$pgis_asgeobuf_transfn$function$\n",
      "language": "c",
      "arguments": "internal, anyelement, text",
      "volatility": "immutable",
      "description": null,
      "result_type": "internal",
      "security_definer": false
    },
    {
      "name": "pgis_asgeobuf_finalfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_asgeobuf_finalfn(internal)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE COST 500\nAS '$libdir/postgis-3', $function$pgis_asgeobuf_finalfn$function$\n",
      "language": "c",
      "arguments": "internal",
      "volatility": "immutable",
      "description": null,
      "result_type": "bytea",
      "security_definer": false
    },
    {
      "name": "pgis_asflatgeobuf_transfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_asflatgeobuf_transfn(internal, anyelement)\n RETURNS internal\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE COST 50\nAS '$libdir/postgis-3', $function$pgis_asflatgeobuf_transfn$function$\n",
      "language": "c",
      "arguments": "internal, anyelement",
      "volatility": "immutable",
      "description": null,
      "result_type": "internal",
      "security_definer": false
    },
    {
      "name": "pgis_asflatgeobuf_transfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_asflatgeobuf_transfn(internal, anyelement, boolean)\n RETURNS internal\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE COST 50\nAS '$libdir/postgis-3', $function$pgis_asflatgeobuf_transfn$function$\n",
      "language": "c",
      "arguments": "internal, anyelement, boolean",
      "volatility": "immutable",
      "description": null,
      "result_type": "internal",
      "security_definer": false
    },
    {
      "name": "pgis_asflatgeobuf_transfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_asflatgeobuf_transfn(internal, anyelement, boolean, text)\n RETURNS internal\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE COST 50\nAS '$libdir/postgis-3', $function$pgis_asflatgeobuf_transfn$function$\n",
      "language": "c",
      "arguments": "internal, anyelement, boolean, text",
      "volatility": "immutable",
      "description": null,
      "result_type": "internal",
      "security_definer": false
    },
    {
      "name": "pgis_asflatgeobuf_finalfn",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.pgis_asflatgeobuf_finalfn(internal)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE COST 500\nAS '$libdir/postgis-3', $function$pgis_asflatgeobuf_finalfn$function$\n",
      "language": "c",
      "arguments": "internal",
      "volatility": "immutable",
      "description": null,
      "result_type": "bytea",
      "security_definer": false
    },
    {
      "name": "_st_sortablehash",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_sortablehash(geom geometry)\n RETURNS bigint\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 50\nAS '$libdir/postgis-3', $function$_ST_SortableHash$function$\n",
      "language": "c",
      "arguments": "geom geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "bigint",
      "security_definer": false
    },
    {
      "name": "_st_maxdistance",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_maxdistance(geom1 geometry, geom2 geometry)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 500\nAS '$libdir/postgis-3', $function$LWGEOM_maxdistance2d_linestring$function$\n",
      "language": "c",
      "arguments": "geom1 geometry, geom2 geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "double precision",
      "security_definer": false
    },
    {
      "name": "_st_longestline",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_longestline(geom1 geometry, geom2 geometry)\n RETURNS geometry\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 500\nAS '$libdir/postgis-3', $function$LWGEOM_longestline2d$function$\n",
      "language": "c",
      "arguments": "geom1 geometry, geom2 geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "geometry",
      "security_definer": false
    },
    {
      "name": "unlockrows",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.unlockrows(text)\n RETURNS integer\n LANGUAGE plpgsql\n STRICT\nAS $function$\nDECLARE\n\tret int;\nBEGIN\n\n\tIF NOT LongTransactionsEnabled() THEN\n\t\tRAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';\n\tEND IF;\n\n\tEXECUTE 'DELETE FROM authorization_table where authid = ' ||\n\t\tquote_literal($1);\n\n\tGET DIAGNOSTICS ret = ROW_COUNT;\n\n\tRETURN ret;\nEND;\n$function$\n",
      "language": "plpgsql",
      "arguments": "text",
      "volatility": "volatile",
      "description": "args: auth_token - Removes all locks held by an authorization token.",
      "result_type": "integer",
      "security_definer": false
    },
    {
      "name": "lockrow",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.lockrow(text, text, text, text, timestamp without time zone)\n RETURNS integer\n LANGUAGE plpgsql\n STRICT\nAS $function$\nDECLARE\n\tmyschema alias for $1;\n\tmytable alias for $2;\n\tmyrid   alias for $3;\n\tauthid alias for $4;\n\texpires alias for $5;\n\tret int;\n\tmytoid oid;\n\tmyrec RECORD;\n\nBEGIN\n\n\tIF NOT LongTransactionsEnabled() THEN\n\t\tRAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';\n\tEND IF;\n\n\tEXECUTE 'DELETE FROM authorization_table WHERE expires < now()';\n\n\tSELECT c.oid INTO mytoid FROM pg_class c, pg_namespace n\n\t\tWHERE c.relname = mytable\n\t\tAND c.relnamespace = n.oid\n\t\tAND n.nspname = myschema;\n\n\t-- RAISE NOTICE 'toid: %', mytoid;\n\n\tFOR myrec IN SELECT * FROM authorization_table WHERE\n\t\ttoid = mytoid AND rid = myrid\n\tLOOP\n\t\tIF myrec.authid != authid THEN\n\t\t\tRETURN 0;\n\t\tELSE\n\t\t\tRETURN 1;\n\t\tEND IF;\n\tEND LOOP;\n\n\tEXECUTE 'INSERT INTO authorization_table VALUES ('||\n\t\tquote_literal(mytoid::text)||','||quote_literal(myrid)||\n\t\t','||quote_literal(expires::text)||\n\t\t','||quote_literal(authid) ||')';\n\n\tGET DIAGNOSTICS ret = ROW_COUNT;\n\n\tRETURN ret;\nEND;\n$function$\n",
      "language": "plpgsql",
      "arguments": "text, text, text, text, timestamp without time zone",
      "volatility": "volatile",
      "description": "args: a_schema_name, a_table_name, a_row_key, an_auth_token, expire_dt - Sets lock/authorization for a row in a table.",
      "result_type": "integer",
      "security_definer": false
    },
    {
      "name": "lockrow",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.lockrow(text, text, text, text)\n RETURNS integer\n LANGUAGE sql\n STRICT\nAS $function$ SELECT LockRow($1, $2, $3, $4, now()::timestamp+'1:00'); $function$\n",
      "language": "sql",
      "arguments": "text, text, text, text",
      "volatility": "volatile",
      "description": null,
      "result_type": "integer",
      "security_definer": false
    },
    {
      "name": "lockrow",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.lockrow(text, text, text)\n RETURNS integer\n LANGUAGE sql\n STRICT\nAS $function$ SELECT LockRow(current_schema(), $1, $2, $3, now()::timestamp+'1:00'); $function$\n",
      "language": "sql",
      "arguments": "text, text, text",
      "volatility": "volatile",
      "description": "args: a_table_name, a_row_key, an_auth_token - Sets lock/authorization for a row in a table.",
      "result_type": "integer",
      "security_definer": false
    },
    {
      "name": "lockrow",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.lockrow(text, text, text, timestamp without time zone)\n RETURNS integer\n LANGUAGE sql\n STRICT\nAS $function$ SELECT LockRow(current_schema(), $1, $2, $3, $4); $function$\n",
      "language": "sql",
      "arguments": "text, text, text, timestamp without time zone",
      "volatility": "volatile",
      "description": "args: a_table_name, a_row_key, an_auth_token, expire_dt - Sets lock/authorization for a row in a table.",
      "result_type": "integer",
      "security_definer": false
    },
    {
      "name": "addauth",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.addauth(text)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n\tlockid alias for $1;\n\tokay boolean;\n\tmyrec record;\nBEGIN\n\t-- check to see if table exists\n\t--  if not, CREATE TEMP TABLE mylock (transid xid, lockcode text)\n\tokay := 'f';\n\tFOR myrec IN SELECT * FROM pg_class WHERE relname = 'temp_lock_have_table' LOOP\n\t\tokay := 't';\n\tEND LOOP;\n\tIF (okay <> 't') THEN\n\t\tCREATE TEMP TABLE temp_lock_have_table (transid xid, lockcode text);\n\t\t\t-- this will only work from pgsql7.4 up\n\t\t\t-- ON COMMIT DELETE ROWS;\n\tEND IF;\n\n\t--  INSERT INTO mylock VALUES ( $1)\n--\tEXECUTE 'INSERT INTO temp_lock_have_table VALUES ( '||\n--\t\tquote_literal(getTransactionID()) || ',' ||\n--\t\tquote_literal(lockid) ||')';\n\n\tINSERT INTO temp_lock_have_table VALUES (getTransactionID(), lockid);\n\n\tRETURN true::boolean;\nEND;\n$function$\n",
      "language": "plpgsql",
      "arguments": "text",
      "volatility": "volatile",
      "description": "args: auth_token - Adds an authorization token to be used in the current transaction.",
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "checkauth",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.checkauth(text, text, text)\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n\tschema text;\nBEGIN\n\tIF NOT LongTransactionsEnabled() THEN\n\t\tRAISE EXCEPTION 'Long transaction support disabled, use EnableLongTransaction() to enable.';\n\tEND IF;\n\n\tif ( $1 != '' ) THEN\n\t\tschema = $1;\n\tELSE\n\t\tSELECT current_schema() into schema;\n\tEND IF;\n\n\t-- TODO: check for an already existing trigger ?\n\n\tEXECUTE 'CREATE TRIGGER check_auth BEFORE UPDATE OR DELETE ON '\n\t\t|| quote_ident(schema) || '.' || quote_ident($2)\n\t\t||' FOR EACH ROW EXECUTE PROCEDURE CheckAuthTrigger('\n\t\t|| quote_literal($3) || ')';\n\n\tRETURN 0;\nEND;\n$function$\n",
      "language": "plpgsql",
      "arguments": "text, text, text",
      "volatility": "volatile",
      "description": "args: a_schema_name, a_table_name, a_key_column_name - Creates a trigger on a table to prevent/allow updates and deletes of rows based on authorization token.",
      "result_type": "integer",
      "security_definer": false
    },
    {
      "name": "checkauth",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.checkauth(text, text)\n RETURNS integer\n LANGUAGE sql\nAS $function$ SELECT CheckAuth('', $1, $2) $function$\n",
      "language": "sql",
      "arguments": "text, text",
      "volatility": "volatile",
      "description": "args: a_table_name, a_key_column_name - Creates a trigger on a table to prevent/allow updates and deletes of rows based on authorization token.",
      "result_type": "integer",
      "security_definer": false
    },
    {
      "name": "checkauthtrigger",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.checkauthtrigger()\n RETURNS trigger\n LANGUAGE c\nAS '$libdir/postgis-3', $function$check_authorization$function$\n",
      "language": "c",
      "arguments": "",
      "volatility": "volatile",
      "description": null,
      "result_type": "trigger",
      "security_definer": false
    },
    {
      "name": "gettransactionid",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.gettransactionid()\n RETURNS xid\n LANGUAGE c\nAS '$libdir/postgis-3', $function$getTransactionID$function$\n",
      "language": "c",
      "arguments": "",
      "volatility": "volatile",
      "description": null,
      "result_type": "xid",
      "security_definer": false
    },
    {
      "name": "postgis_typmod_srid",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_typmod_srid(integer)\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$postgis_typmod_srid$function$\n",
      "language": "c",
      "arguments": "integer",
      "volatility": "immutable",
      "description": null,
      "result_type": "integer",
      "security_definer": false
    },
    {
      "name": "postgis_typmod_type",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_typmod_type(integer)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$postgis_typmod_type$function$\n",
      "language": "c",
      "arguments": "integer",
      "volatility": "immutable",
      "description": null,
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "enablelongtransactions",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.enablelongtransactions()\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n\t\"query\" text;\n\texists bool;\n\trec RECORD;\n\nBEGIN\n\n\texists = 'f';\n\tFOR rec IN SELECT * FROM pg_class WHERE relname = 'authorization_table'\n\tLOOP\n\t\texists = 't';\n\tEND LOOP;\n\n\tIF NOT exists\n\tTHEN\n\t\t\"query\" = 'CREATE TABLE authorization_table (\n\t\t\ttoid oid, -- table oid\n\t\t\trid text, -- row id\n\t\t\texpires timestamp,\n\t\t\tauthid text\n\t\t)';\n\t\tEXECUTE \"query\";\n\tEND IF;\n\n\texists = 'f';\n\tFOR rec IN SELECT * FROM pg_class WHERE relname = 'authorized_tables'\n\tLOOP\n\t\texists = 't';\n\tEND LOOP;\n\n\tIF NOT exists THEN\n\t\t\"query\" = 'CREATE VIEW authorized_tables AS ' ||\n\t\t\t'SELECT ' ||\n\t\t\t'n.nspname as schema, ' ||\n\t\t\t'c.relname as table, trim(' ||\n\t\t\tquote_literal(chr(92) || '000') ||\n\t\t\t' from t.tgargs) as id_column ' ||\n\t\t\t'FROM pg_trigger t, pg_class c, pg_proc p ' ||\n\t\t\t', pg_namespace n ' ||\n\t\t\t'WHERE p.proname = ' || quote_literal('checkauthtrigger') ||\n\t\t\t' AND c.relnamespace = n.oid' ||\n\t\t\t' AND t.tgfoid = p.oid and t.tgrelid = c.oid';\n\t\tEXECUTE \"query\";\n\tEND IF;\n\n\tRETURN 'Long transactions support enabled';\nEND;\n$function$\n",
      "language": "plpgsql",
      "arguments": "",
      "volatility": "volatile",
      "description": "Enables long transaction support.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "longtransactionsenabled",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.longtransactionsenabled()\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n\trec RECORD;\nBEGIN\n\tFOR rec IN SELECT oid FROM pg_class WHERE relname = 'authorized_tables'\n\tLOOP\n\t\treturn 't';\n\tEND LOOP;\n\treturn 'f';\nEND;\n$function$\n",
      "language": "plpgsql",
      "arguments": "",
      "volatility": "volatile",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "disablelongtransactions",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.disablelongtransactions()\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n\trec RECORD;\n\nBEGIN\n\n\t--\n\t-- Drop all triggers applied by CheckAuth()\n\t--\n\tFOR rec IN\n\t\tSELECT c.relname, t.tgname, t.tgargs FROM pg_trigger t, pg_class c, pg_proc p\n\t\tWHERE p.proname = 'checkauthtrigger' and t.tgfoid = p.oid and t.tgrelid = c.oid\n\tLOOP\n\t\tEXECUTE 'DROP TRIGGER ' || quote_ident(rec.tgname) ||\n\t\t\t' ON ' || quote_ident(rec.relname);\n\tEND LOOP;\n\n\t--\n\t-- Drop the authorization_table table\n\t--\n\tFOR rec IN SELECT * FROM pg_class WHERE relname = 'authorization_table' LOOP\n\t\tDROP TABLE authorization_table;\n\tEND LOOP;\n\n\t--\n\t-- Drop the authorized_tables view\n\t--\n\tFOR rec IN SELECT * FROM pg_class WHERE relname = 'authorized_tables' LOOP\n\t\tDROP VIEW authorized_tables;\n\tEND LOOP;\n\n\tRETURN 'Long transactions support disabled';\nEND;\n$function$\n",
      "language": "plpgsql",
      "arguments": "",
      "volatility": "volatile",
      "description": "Disables long transaction support.",
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "geography",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.geography(geography, integer, boolean)\n RETURNS geography\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$geography_enforce_typmod$function$\n",
      "language": "c",
      "arguments": "geography, integer, boolean",
      "volatility": "immutable",
      "description": null,
      "result_type": "geography",
      "security_definer": false
    },
    {
      "name": "geography",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.geography(bytea)\n RETURNS geography\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$geography_from_binary$function$\n",
      "language": "c",
      "arguments": "bytea",
      "volatility": "immutable",
      "description": null,
      "result_type": "geography",
      "security_definer": false
    },
    {
      "name": "bytea",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.bytea(geography)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$LWGEOM_to_bytea$function$\n",
      "language": "c",
      "arguments": "geography",
      "volatility": "immutable",
      "description": null,
      "result_type": "bytea",
      "security_definer": false
    },
    {
      "name": "postgis_typmod_dims",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_typmod_dims(integer)\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$postgis_typmod_dims$function$\n",
      "language": "c",
      "arguments": "integer",
      "volatility": "immutable",
      "description": null,
      "result_type": "integer",
      "security_definer": false
    },
    {
      "name": "geography",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.geography(geometry)\n RETURNS geography\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$geography_from_geometry$function$\n",
      "language": "c",
      "arguments": "geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "geography",
      "security_definer": false
    },
    {
      "name": "geometry",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.geometry(geography)\n RETURNS geometry\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$geometry_from_geography$function$\n",
      "language": "c",
      "arguments": "geography",
      "volatility": "immutable",
      "description": null,
      "result_type": "geometry",
      "security_definer": false
    },
    {
      "name": "overlaps_geog",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.overlaps_geog(gidx, geography)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE STRICT\nAS '$libdir/postgis-3', $function$gserialized_gidx_geog_overlaps$function$\n",
      "language": "c",
      "arguments": "gidx, geography",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "overlaps_geog",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.overlaps_geog(gidx, gidx)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE STRICT\nAS '$libdir/postgis-3', $function$gserialized_gidx_gidx_overlaps$function$\n",
      "language": "c",
      "arguments": "gidx, gidx",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "overlaps_geog",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.overlaps_geog(geography, gidx)\n RETURNS boolean\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$SELECT $2 OPERATOR(public.&&) $1;$function$\n",
      "language": "sql",
      "arguments": "geography, gidx",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "geog_brin_inclusion_add_value",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.geog_brin_inclusion_add_value(internal, internal, internal, internal)\n RETURNS boolean\n LANGUAGE c\nAS '$libdir/postgis-3', $function$geog_brin_inclusion_add_value$function$\n",
      "language": "c",
      "arguments": "internal, internal, internal, internal",
      "volatility": "volatile",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "_st_expand",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_expand(geography, double precision)\n RETURNS geography\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 50\nAS '$libdir/postgis-3', $function$geography_expand$function$\n",
      "language": "c",
      "arguments": "geography, double precision",
      "volatility": "immutable",
      "description": null,
      "result_type": "geography",
      "security_definer": false
    },
    {
      "name": "_st_distanceuncached",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_distanceuncached(geography, geography, double precision, boolean)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE STRICT COST 10000\nAS '$libdir/postgis-3', $function$geography_distance_uncached$function$\n",
      "language": "c",
      "arguments": "geography, geography, double precision, boolean",
      "volatility": "immutable",
      "description": null,
      "result_type": "double precision",
      "security_definer": false
    },
    {
      "name": "_st_distanceuncached",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_distanceuncached(geography, geography, boolean)\n RETURNS double precision\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$SELECT public._ST_DistanceUnCached($1, $2, 0.0, $3)$function$\n",
      "language": "sql",
      "arguments": "geography, geography, boolean",
      "volatility": "immutable",
      "description": null,
      "result_type": "double precision",
      "security_definer": false
    },
    {
      "name": "_st_distanceuncached",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_distanceuncached(geography, geography)\n RETURNS double precision\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$SELECT public._ST_DistanceUnCached($1, $2, 0.0, true)$function$\n",
      "language": "sql",
      "arguments": "geography, geography",
      "volatility": "immutable",
      "description": null,
      "result_type": "double precision",
      "security_definer": false
    },
    {
      "name": "_st_distancetree",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_distancetree(geography, geography, double precision, boolean)\n RETURNS double precision\n LANGUAGE c\n IMMUTABLE STRICT COST 10000\nAS '$libdir/postgis-3', $function$geography_distance_tree$function$\n",
      "language": "c",
      "arguments": "geography, geography, double precision, boolean",
      "volatility": "immutable",
      "description": null,
      "result_type": "double precision",
      "security_definer": false
    },
    {
      "name": "_st_distancetree",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_distancetree(geography, geography)\n RETURNS double precision\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$SELECT public._ST_DistanceTree($1, $2, 0.0, true)$function$\n",
      "language": "sql",
      "arguments": "geography, geography",
      "volatility": "immutable",
      "description": null,
      "result_type": "double precision",
      "security_definer": false
    },
    {
      "name": "_st_dwithinuncached",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_dwithinuncached(geography, geography, double precision, boolean)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE STRICT COST 10000\nAS '$libdir/postgis-3', $function$geography_dwithin_uncached$function$\n",
      "language": "c",
      "arguments": "geography, geography, double precision, boolean",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "_st_dwithinuncached",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_dwithinuncached(geography, geography, double precision)\n RETURNS boolean\n LANGUAGE sql\n IMMUTABLE\nAS $function$SELECT $1 OPERATOR(public.&&) public._ST_Expand($2,$3) AND $2 OPERATOR(public.&&) public._ST_Expand($1,$3) AND public._ST_DWithinUnCached($1, $2, $3, true)$function$\n",
      "language": "sql",
      "arguments": "geography, geography, double precision",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "_st_pointoutside",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_pointoutside(geography)\n RETURNS geography\n LANGUAGE c\n IMMUTABLE STRICT\nAS '$libdir/postgis-3', $function$geography_point_outside$function$\n",
      "language": "c",
      "arguments": "geography",
      "volatility": "immutable",
      "description": null,
      "result_type": "geography",
      "security_definer": false
    },
    {
      "name": "_st_bestsrid",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_bestsrid(geography, geography)\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 50\nAS '$libdir/postgis-3', $function$geography_bestsrid$function$\n",
      "language": "c",
      "arguments": "geography, geography",
      "volatility": "immutable",
      "description": null,
      "result_type": "integer",
      "security_definer": false
    },
    {
      "name": "_st_bestsrid",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_bestsrid(geography)\n RETURNS integer\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 50\nAS '$libdir/postgis-3', $function$geography_bestsrid$function$\n",
      "language": "c",
      "arguments": "geography",
      "volatility": "immutable",
      "description": null,
      "result_type": "integer",
      "security_definer": false
    },
    {
      "name": "_st_covers",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_covers(geog1 geography, geog2 geography)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 10000\nAS '$libdir/postgis-3', $function$geography_covers$function$\n",
      "language": "c",
      "arguments": "geog1 geography, geog2 geography",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "_st_dwithin",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_dwithin(geog1 geography, geog2 geography, tolerance double precision, use_spheroid boolean DEFAULT true)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 10000\nAS '$libdir/postgis-3', $function$geography_dwithin$function$\n",
      "language": "c",
      "arguments": "geog1 geography, geog2 geography, tolerance double precision, use_spheroid boolean DEFAULT true",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "_st_coveredby",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_coveredby(geog1 geography, geog2 geography)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT COST 10000\nAS '$libdir/postgis-3', $function$geography_coveredby$function$\n",
      "language": "c",
      "arguments": "geog1 geography, geog2 geography",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "postgis_type_name",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_type_name(geomname character varying, coord_dimension integer, use_new_name boolean DEFAULT true)\n RETURNS character varying\n LANGUAGE sql\n IMMUTABLE PARALLEL SAFE STRICT COST 10000\nAS $function$\n\tSELECT CASE WHEN $3 THEN new_name ELSE old_name END As geomname\n\tFROM\n\t( VALUES\n\t\t\t('GEOMETRY', 'Geometry', 2),\n\t\t\t('GEOMETRY', 'GeometryZ', 3),\n\t\t\t('GEOMETRYM', 'GeometryM', 3),\n\t\t\t('GEOMETRY', 'GeometryZM', 4),\n\n\t\t\t('GEOMETRYCOLLECTION', 'GeometryCollection', 2),\n\t\t\t('GEOMETRYCOLLECTION', 'GeometryCollectionZ', 3),\n\t\t\t('GEOMETRYCOLLECTIONM', 'GeometryCollectionM', 3),\n\t\t\t('GEOMETRYCOLLECTION', 'GeometryCollectionZM', 4),\n\n\t\t\t('POINT', 'Point', 2),\n\t\t\t('POINT', 'PointZ', 3),\n\t\t\t('POINTM','PointM', 3),\n\t\t\t('POINT', 'PointZM', 4),\n\n\t\t\t('MULTIPOINT','MultiPoint', 2),\n\t\t\t('MULTIPOINT','MultiPointZ', 3),\n\t\t\t('MULTIPOINTM','MultiPointM', 3),\n\t\t\t('MULTIPOINT','MultiPointZM', 4),\n\n\t\t\t('POLYGON', 'Polygon', 2),\n\t\t\t('POLYGON', 'PolygonZ', 3),\n\t\t\t('POLYGONM', 'PolygonM', 3),\n\t\t\t('POLYGON', 'PolygonZM', 4),\n\n\t\t\t('MULTIPOLYGON', 'MultiPolygon', 2),\n\t\t\t('MULTIPOLYGON', 'MultiPolygonZ', 3),\n\t\t\t('MULTIPOLYGONM', 'MultiPolygonM', 3),\n\t\t\t('MULTIPOLYGON', 'MultiPolygonZM', 4),\n\n\t\t\t('MULTILINESTRING', 'MultiLineString', 2),\n\t\t\t('MULTILINESTRING', 'MultiLineStringZ', 3),\n\t\t\t('MULTILINESTRINGM', 'MultiLineStringM', 3),\n\t\t\t('MULTILINESTRING', 'MultiLineStringZM', 4),\n\n\t\t\t('LINESTRING', 'LineString', 2),\n\t\t\t('LINESTRING', 'LineStringZ', 3),\n\t\t\t('LINESTRINGM', 'LineStringM', 3),\n\t\t\t('LINESTRING', 'LineStringZM', 4),\n\n\t\t\t('CIRCULARSTRING', 'CircularString', 2),\n\t\t\t('CIRCULARSTRING', 'CircularStringZ', 3),\n\t\t\t('CIRCULARSTRINGM', 'CircularStringM' ,3),\n\t\t\t('CIRCULARSTRING', 'CircularStringZM', 4),\n\n\t\t\t('COMPOUNDCURVE', 'CompoundCurve', 2),\n\t\t\t('COMPOUNDCURVE', 'CompoundCurveZ', 3),\n\t\t\t('COMPOUNDCURVEM', 'CompoundCurveM', 3),\n\t\t\t('COMPOUNDCURVE', 'CompoundCurveZM', 4),\n\n\t\t\t('CURVEPOLYGON', 'CurvePolygon', 2),\n\t\t\t('CURVEPOLYGON', 'CurvePolygonZ', 3),\n\t\t\t('CURVEPOLYGONM', 'CurvePolygonM', 3),\n\t\t\t('CURVEPOLYGON', 'CurvePolygonZM', 4),\n\n\t\t\t('MULTICURVE', 'MultiCurve', 2),\n\t\t\t('MULTICURVE', 'MultiCurveZ', 3),\n\t\t\t('MULTICURVEM', 'MultiCurveM', 3),\n\t\t\t('MULTICURVE', 'MultiCurveZM', 4),\n\n\t\t\t('MULTISURFACE', 'MultiSurface', 2),\n\t\t\t('MULTISURFACE', 'MultiSurfaceZ', 3),\n\t\t\t('MULTISURFACEM', 'MultiSurfaceM', 3),\n\t\t\t('MULTISURFACE', 'MultiSurfaceZM', 4),\n\n\t\t\t('POLYHEDRALSURFACE', 'PolyhedralSurface', 2),\n\t\t\t('POLYHEDRALSURFACE', 'PolyhedralSurfaceZ', 3),\n\t\t\t('POLYHEDRALSURFACEM', 'PolyhedralSurfaceM', 3),\n\t\t\t('POLYHEDRALSURFACE', 'PolyhedralSurfaceZM', 4),\n\n\t\t\t('TRIANGLE', 'Triangle', 2),\n\t\t\t('TRIANGLE', 'TriangleZ', 3),\n\t\t\t('TRIANGLEM', 'TriangleM', 3),\n\t\t\t('TRIANGLE', 'TriangleZM', 4),\n\n\t\t\t('TIN', 'Tin', 2),\n\t\t\t('TIN', 'TinZ', 3),\n\t\t\t('TINM', 'TinM', 3),\n\t\t\t('TIN', 'TinZM', 4) )\n\t\t\t As g(old_name, new_name, coord_dimension)\n\tWHERE (upper(old_name) = upper($1) OR upper(new_name) = upper($1))\n\t\tAND coord_dimension = $2;\n$function$\n",
      "language": "sql",
      "arguments": "geomname character varying, coord_dimension integer, use_new_name boolean DEFAULT true",
      "volatility": "immutable",
      "description": null,
      "result_type": "character varying",
      "security_definer": false
    },
    {
      "name": "postgis_constraint_srid",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_constraint_srid(geomschema text, geomtable text, geomcolumn text)\n RETURNS integer\n LANGUAGE sql\n STABLE PARALLEL SAFE STRICT COST 500\nAS $function$\nSELECT replace(replace(split_part(s.consrc, ' = ', 2), ')', ''), '(', '')::integer\n\t\t FROM pg_class c, pg_namespace n, pg_attribute a\n\t\t , (SELECT connamespace, conrelid, conkey, pg_get_constraintdef(oid) As consrc\n\t\t\tFROM pg_constraint) AS s\n\t\t WHERE n.nspname = $1\n\t\t AND c.relname = $2\n\t\t AND a.attname = $3\n\t\t AND a.attrelid = c.oid\n\t\t AND s.connamespace = n.oid\n\t\t AND s.conrelid = c.oid\n\t\t AND a.attnum = ANY (s.conkey)\n\t\t AND s.consrc LIKE '%srid(% = %';\n$function$\n",
      "language": "sql",
      "arguments": "geomschema text, geomtable text, geomcolumn text",
      "volatility": "stable",
      "description": null,
      "result_type": "integer",
      "security_definer": false
    },
    {
      "name": "postgis_constraint_dims",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_constraint_dims(geomschema text, geomtable text, geomcolumn text)\n RETURNS integer\n LANGUAGE sql\n STABLE PARALLEL SAFE STRICT COST 500\nAS $function$\nSELECT  replace(split_part(s.consrc, ' = ', 2), ')', '')::integer\n\t\t FROM pg_class c, pg_namespace n, pg_attribute a\n\t\t , (SELECT connamespace, conrelid, conkey, pg_get_constraintdef(oid) As consrc\n\t\t\tFROM pg_constraint) AS s\n\t\t WHERE n.nspname = $1\n\t\t AND c.relname = $2\n\t\t AND a.attname = $3\n\t\t AND a.attrelid = c.oid\n\t\t AND s.connamespace = n.oid\n\t\t AND s.conrelid = c.oid\n\t\t AND a.attnum = ANY (s.conkey)\n\t\t AND s.consrc LIKE '%ndims(% = %';\n$function$\n",
      "language": "sql",
      "arguments": "geomschema text, geomtable text, geomcolumn text",
      "volatility": "stable",
      "description": null,
      "result_type": "integer",
      "security_definer": false
    },
    {
      "name": "postgis_constraint_type",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.postgis_constraint_type(geomschema text, geomtable text, geomcolumn text)\n RETURNS character varying\n LANGUAGE sql\n STABLE PARALLEL SAFE STRICT COST 500\nAS $function$\nSELECT  replace(split_part(s.consrc, '''', 2), ')', '')::varchar\n\t\t FROM pg_class c, pg_namespace n, pg_attribute a\n\t\t , (SELECT connamespace, conrelid, conkey, pg_get_constraintdef(oid) As consrc\n\t\t\tFROM pg_constraint) AS s\n\t\t WHERE n.nspname = $1\n\t\t AND c.relname = $2\n\t\t AND a.attname = $3\n\t\t AND a.attrelid = c.oid\n\t\t AND s.connamespace = n.oid\n\t\t AND s.conrelid = c.oid\n\t\t AND a.attnum = ANY (s.conkey)\n\t\t AND s.consrc LIKE '%geometrytype(% = %';\n$function$\n",
      "language": "sql",
      "arguments": "geomschema text, geomtable text, geomcolumn text",
      "volatility": "stable",
      "description": null,
      "result_type": "character varying",
      "security_definer": false
    },
    {
      "name": "contains_2d",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.contains_2d(box2df, geometry)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$gserialized_contains_box2df_geom_2d$function$\n",
      "language": "c",
      "arguments": "box2df, geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "is_contained_2d",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.is_contained_2d(box2df, geometry)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$gserialized_within_box2df_geom_2d$function$\n",
      "language": "c",
      "arguments": "box2df, geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "overlaps_2d",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.overlaps_2d(box2df, geometry)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$gserialized_overlaps_box2df_geom_2d$function$\n",
      "language": "c",
      "arguments": "box2df, geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "overlaps_2d",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.overlaps_2d(box2df, box2df)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$gserialized_contains_box2df_box2df_2d$function$\n",
      "language": "c",
      "arguments": "box2df, box2df",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "contains_2d",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.contains_2d(box2df, box2df)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$gserialized_contains_box2df_box2df_2d$function$\n",
      "language": "c",
      "arguments": "box2df, box2df",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "is_contained_2d",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.is_contained_2d(box2df, box2df)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$gserialized_contains_box2df_box2df_2d$function$\n",
      "language": "c",
      "arguments": "box2df, box2df",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "contains_2d",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.contains_2d(geometry, box2df)\n RETURNS boolean\n LANGUAGE sql\n IMMUTABLE PARALLEL SAFE STRICT COST 1\nAS $function$SELECT $2 OPERATOR(public.@) $1;$function$\n",
      "language": "sql",
      "arguments": "geometry, box2df",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "is_contained_2d",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.is_contained_2d(geometry, box2df)\n RETURNS boolean\n LANGUAGE sql\n IMMUTABLE PARALLEL SAFE STRICT COST 1\nAS $function$SELECT $2 OPERATOR(public.~) $1;$function$\n",
      "language": "sql",
      "arguments": "geometry, box2df",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "overlaps_2d",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.overlaps_2d(geometry, box2df)\n RETURNS boolean\n LANGUAGE sql\n IMMUTABLE PARALLEL SAFE STRICT COST 1\nAS $function$SELECT $2 OPERATOR(public.&&) $1;$function$\n",
      "language": "sql",
      "arguments": "geometry, box2df",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "overlaps_nd",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.overlaps_nd(gidx, geometry)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$gserialized_gidx_geom_overlaps$function$\n",
      "language": "c",
      "arguments": "gidx, geometry",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "overlaps_nd",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.overlaps_nd(gidx, gidx)\n RETURNS boolean\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/postgis-3', $function$gserialized_gidx_gidx_overlaps$function$\n",
      "language": "c",
      "arguments": "gidx, gidx",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "overlaps_nd",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.overlaps_nd(geometry, gidx)\n RETURNS boolean\n LANGUAGE sql\n IMMUTABLE PARALLEL SAFE STRICT COST 1\nAS $function$SELECT $2 OPERATOR(public.&&&) $1;$function$\n",
      "language": "sql",
      "arguments": "geometry, gidx",
      "volatility": "immutable",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "geom2d_brin_inclusion_add_value",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.geom2d_brin_inclusion_add_value(internal, internal, internal, internal)\n RETURNS boolean\n LANGUAGE c\n PARALLEL SAFE\nAS '$libdir/postgis-3', $function$geom2d_brin_inclusion_add_value$function$\n",
      "language": "c",
      "arguments": "internal, internal, internal, internal",
      "volatility": "volatile",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "geom3d_brin_inclusion_add_value",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.geom3d_brin_inclusion_add_value(internal, internal, internal, internal)\n RETURNS boolean\n LANGUAGE c\n PARALLEL SAFE\nAS '$libdir/postgis-3', $function$geom3d_brin_inclusion_add_value$function$\n",
      "language": "c",
      "arguments": "internal, internal, internal, internal",
      "volatility": "volatile",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "geom4d_brin_inclusion_add_value",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.geom4d_brin_inclusion_add_value(internal, internal, internal, internal)\n RETURNS boolean\n LANGUAGE c\n PARALLEL SAFE\nAS '$libdir/postgis-3', $function$geom4d_brin_inclusion_add_value$function$\n",
      "language": "c",
      "arguments": "internal, internal, internal, internal",
      "volatility": "volatile",
      "description": null,
      "result_type": "boolean",
      "security_definer": false
    },
    {
      "name": "_st_asx3d",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public._st_asx3d(integer, geometry, integer, integer, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE COST 500\nAS '$libdir/postgis-3', $function$LWGEOM_asX3D$function$\n",
      "language": "c",
      "arguments": "integer, geometry, integer, integer, text",
      "volatility": "immutable",
      "description": null,
      "result_type": "text",
      "security_definer": false
    },
    {
      "name": "update_updated_at",
      "type": "function",
      "source": "CREATE OR REPLACE FUNCTION public.update_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = now();\n    RETURN NEW;\nEND;\n$function$\n",
      "language": "plpgsql",
      "arguments": "",
      "volatility": "volatile",
      "description": null,
      "result_type": "trigger",
      "security_definer": false
    }
  ],
  "foreign_keys": [
    {
      "references": {
        "table": "sites",
        "column": "id",
        "schema": "public"
      },
      "table_name": "references",
      "column_name": "site_id"
    },
    {
      "references": {
        "table": "sites",
        "column": "id",
        "schema": "public"
      },
      "table_name": "unesco_sites",
      "column_name": "site_id"
    }
  ]
}